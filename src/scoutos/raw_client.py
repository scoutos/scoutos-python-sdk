# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from . import core
from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.datetime_utils import serialize_datetime
from .core.http_response import AsyncHttpResponse, HttpResponse
from .core.jsonable_encoder import jsonable_encoder
from .core.request_options import RequestOptions
from .core.serialization import convert_and_respect_annotation_metadata
from .core.unchecked_base_model import construct_type
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .types.agent_revision import AgentRevision
from .types.cancel_response import CancelResponse
from .types.connect_integration_request_auth_type import ConnectIntegrationRequestAuthType
from .types.create_entity_request import CreateEntityRequest
from .types.create_hook_webhooks_post_request import CreateHookWebhooksPostRequest
from .types.create_hook_webhooks_post_response import CreateHookWebhooksPostResponse
from .types.create_integrations_response import CreateIntegrationsResponse
from .types.create_pulse_response import CreatePulseResponse
from .types.create_tag_response import CreateTagResponse
from .types.delete_hook_response import DeleteHookResponse
from .types.delete_response import DeleteResponse
from .types.entity_search_request_mode import EntitySearchRequestMode
from .types.entity_search_request_return_format import EntitySearchRequestReturnFormat
from .types.execute_tool_response import ExecuteToolResponse
from .types.favorite_ref import FavoriteRef
from .types.files_attribute import FilesAttribute
from .types.files_response import FilesResponse
from .types.fluent_query_request_with_item import FluentQueryRequestWithItem
from .types.get_hook_webhooks_hook_id_details_get_response import GetHookWebhooksHookIdDetailsGetResponse
from .types.hooks_list_response import HooksListResponse
from .types.http_validation_error import HttpValidationError
from .types.integration_connection import IntegrationConnection
from .types.integration_with_connections import IntegrationWithConnections
from .types.list_tags_response import ListTagsResponse
from .types.list_tools_response import ListToolsResponse
from .types.mention import Mention
from .types.participant import Participant
from .types.plan_types import PlanTypes
from .types.pulse_feed_response import PulseFeedResponse
from .types.query_builder_request_group_by_item import QueryBuilderRequestGroupByItem
from .types.query_builder_request_sort_by import QueryBuilderRequestSortBy
from .types.query_builder_request_sort_direction import QueryBuilderRequestSortDirection
from .types.query_builder_request_tag_mode import QueryBuilderRequestTagMode
from .types.rename_response import RenameResponse
from .types.resource import Resource
from .types.result import Result
from .types.schedule import Schedule
from .types.schemas_response import SchemasResponse
from .types.scout_hook_config_http import ScoutHookConfigHttp
from .types.scout_hook_response import ScoutHookResponse
from .types.scout_hook_update_triggering_events_item import ScoutHookUpdateTriggeringEventsItem
from .types.scout_hooks_response import ScoutHooksResponse
from .types.search_request_search_type import SearchRequestSearchType
from .types.src_app_http_routes_billing_billing_hourly_response import SrcAppHttpRoutesBillingBillingHourlyResponse
from .types.src_app_http_routes_billing_change_billing_plan_response import (
    SrcAppHttpRoutesBillingChangeBillingPlanResponse,
)
from .types.src_app_http_routes_billing_create_portal_session_response import (
    SrcAppHttpRoutesBillingCreatePortalSessionResponse,
)
from .types.src_app_http_routes_billing_free_plan_usage_response import SrcAppHttpRoutesBillingFreePlanUsageResponse
from .types.src_app_http_routes_billing_get_billing_response import SrcAppHttpRoutesBillingGetBillingResponse
from .types.src_app_http_routes_billing_get_info_get_info_response import SrcAppHttpRoutesBillingGetInfoGetInfoResponse
from .types.src_app_http_routes_billing_get_invoices_response import SrcAppHttpRoutesBillingGetInvoicesResponse
from .types.src_app_http_routes_billing_get_notifications_response import (
    SrcAppHttpRoutesBillingGetNotificationsResponse,
)
from .types.src_app_http_routes_billing_renew_plans_response import SrcAppHttpRoutesBillingRenewPlansResponse
from .types.src_app_http_routes_collection_parse_file_response import SrcAppHttpRoutesCollectionParseFileResponse
from .types.src_app_http_routes_drive_create_drive_crawl_payload_source_sync_settings import (
    SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings,
)
from .types.src_app_http_routes_inbox_handle_message_incoming_message import (
    SrcAppHttpRoutesInboxHandleMessageIncomingMessage,
)
from .types.src_app_http_routes_inbox_handle_message_interaction_request_participants_item import (
    SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem,
)
from .types.src_app_http_routes_onboarding_handle_get_me_response import SrcAppHttpRoutesOnboardingHandleGetMeResponse
from .types.src_app_http_routes_onboarding_handle_update_me_response import (
    SrcAppHttpRoutesOnboardingHandleUpdateMeResponse,
)
from .types.src_app_http_routes_root_get_info_response import SrcAppHttpRoutesRootGetInfoResponse
from .types.src_app_http_routes_world_interact_incoming_message import SrcAppHttpRoutesWorldInteractIncomingMessage
from .types.store_response import StoreResponse
from .types.tag import Tag
from .types.tags_response import TagsResponse
from .types.tool_details import ToolDetails
from .types.tools_response import ToolsResponse
from .types.update_tag_response import UpdateTagResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawScout:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def info_handler_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesRootGetInfoResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesRootGetInfoResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesRootGetInfoResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesRootGetInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_info_v_2_triggers_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/triggers/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_info_v_2_index_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/index/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_info_v_2_workflows_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/workflows/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_info_v_2_collections_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/collections/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def parse_file_v_2_files_parse_post(
        self,
        *,
        file: core.File,
        return_text: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SrcAppHttpRoutesCollectionParseFileResponse]:
        """
        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        return_text : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesCollectionParseFileResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/files/parse",
            method="POST",
            params={
                "return_text": return_text,
            },
            data={},
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesCollectionParseFileResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesCollectionParseFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_integrations_integrations_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[IntegrationWithConnections]]:
        """
        Get all integrations for an organization

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[IntegrationWithConnections]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[IntegrationWithConnections],
                    construct_type(
                        type_=typing.List[IntegrationWithConnections],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_integration_integrations_integration_id_get(
        self, integration_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[IntegrationWithConnections]:
        """
        Get a specific integration for an organization by its ID.

        Parameters
        ----------
        integration_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IntegrationWithConnections]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"integrations/{jsonable_encoder(integration_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IntegrationWithConnections,
                    construct_type(
                        type_=IntegrationWithConnections,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_integration_connections_integrations_integration_id_connections_get(
        self, integration_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[IntegrationConnection]]:
        """
        Get all integrations for an organization

        Parameters
        ----------
        integration_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[IntegrationConnection]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"integrations/{jsonable_encoder(integration_id)}/connections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[IntegrationConnection],
                    construct_type(
                        type_=typing.List[IntegrationConnection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def connect_integration_integrations_integration_id_connect_post(
        self,
        integration_id: str,
        *,
        auth_type: ConnectIntegrationRequestAuthType,
        api_key: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        state: typing.Optional[str] = OMIT,
        scope: typing.Optional[str] = OMIT,
        client_id: typing.Optional[str] = OMIT,
        client_secret: typing.Optional[str] = OMIT,
        environment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateIntegrationsResponse]:
        """
        Parameters
        ----------
        integration_id : str

        auth_type : ConnectIntegrationRequestAuthType

        api_key : typing.Optional[str]

        code : typing.Optional[str]

        state : typing.Optional[str]

        scope : typing.Optional[str]

        client_id : typing.Optional[str]

        client_secret : typing.Optional[str]

        environment : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateIntegrationsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"integrations/{jsonable_encoder(integration_id)}/connect",
            method="POST",
            json={
                "auth_type": auth_type,
                "api_key": api_key,
                "code": code,
                "state": state,
                "scope": scope,
                "client_id": client_id,
                "client_secret": client_secret,
                "environment": environment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateIntegrationsResponse,
                    construct_type(
                        type_=CreateIntegrationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_send_message_integrations_slack_send_post(
        self,
        *,
        channel_id: str,
        text: str,
        thread_id: typing.Optional[str] = OMIT,
        blocks: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        username: typing.Optional[str] = OMIT,
        icon_url: typing.Optional[str] = OMIT,
        integration_id: typing.Optional[str] = OMIT,
        unfurl_links: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        channel_id : str

        text : str

        thread_id : typing.Optional[str]

        blocks : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]

        username : typing.Optional[str]

        icon_url : typing.Optional[str]

        integration_id : typing.Optional[str]

        unfurl_links : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/slack/send",
            method="POST",
            json={
                "channel_id": channel_id,
                "text": text,
                "thread_id": thread_id,
                "blocks": blocks,
                "username": username,
                "icon_url": icon_url,
                "integration_id": integration_id,
                "unfurl_links": unfurl_links,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_add_reaction_integrations_slack_react_post(
        self,
        *,
        channel_id: str,
        emoji_name: str,
        thread_id: typing.Optional[str] = OMIT,
        integration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        channel_id : str

        emoji_name : str

        thread_id : typing.Optional[str]

        integration_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/slack/react",
            method="POST",
            json={
                "channel_id": channel_id,
                "emoji_name": emoji_name,
                "thread_id": thread_id,
                "integration_id": integration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_get_thread_integrations_slack_thread_get(
        self,
        *,
        channel_id: str,
        thread_id: str,
        integration_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        channel_id : str

        thread_id : str

        integration_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/slack/thread",
            method="GET",
            params={
                "channel_id": channel_id,
                "thread_id": thread_id,
                "integration_id": integration_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_get_team_info_integrations_slack_team_get(
        self, *, team_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Handles the request to get Slack team info

        Parameters
        ----------
        team_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/slack/team",
            method="GET",
            params={
                "team_id": team_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_list_channels_integrations_slack_channels_get(
        self,
        *,
        team_id: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        team_id : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/slack/channels",
            method="GET",
            params={
                "team_id": team_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_migrate_integrations_integrations_migrate_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Migrate integration tokens from Neon to Firestore with KMS encryption.

        This endpoint accepts a list of organization IDs and migrates their Slack and Notion tokens.
        It fetches tokens from the Neon database and stores them in Firestore,
        encrypting the tokens using KMS.

        NOTE: Not a public endpoint - used for internal database migration

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/migrate",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_notion_oauth_integrations_notion_oauth_post(
        self,
        *,
        access_token: str,
        metadata: typing.Dict[str, typing.Optional[typing.Any]],
        integrated_service_id: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        redirect_uri: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Handle Notion OAuth token upsert

        Args:
            request: The FastAPI request object
            body: The request body containing the access token and metadata

        Returns:
            Response indicating success

        Raises:
            HTTPException: If there's an error during the process

        Parameters
        ----------
        access_token : str

        metadata : typing.Dict[str, typing.Optional[typing.Any]]

        integrated_service_id : typing.Optional[str]

        code : typing.Optional[str]

        redirect_uri : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "integrations/notion/oauth",
            method="POST",
            json={
                "access_token": access_token,
                "integrated_service_id": integrated_service_id,
                "metadata": metadata,
                "code": code,
                "redirect_uri": redirect_uri,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def exchange_mcp_auth_mcp_authorization_post(
        self,
        *,
        code: str,
        state: str,
        url: str,
        name: str,
        integration_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        code : str

        state : str

        url : str

        name : str

        integration_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "mcp/authorization",
            method="POST",
            json={
                "code": code,
                "state": state,
                "url": url,
                "name": name,
                "integration_id": integration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def connect_mcp_mcp_connect_post(
        self,
        *,
        url: str,
        name: str,
        integration_id: str,
        headers: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        url : str

        name : str

        integration_id : str

        headers : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "mcp/connect",
            method="POST",
            json={
                "url": url,
                "name": name,
                "headers": headers,
                "integration_id": integration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_mcp_connection_mcp_servers_connection_id_delete(
        self, connection_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        connection_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"mcp/servers/{jsonable_encoder(connection_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_mcp_servers_mcp_servers_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "mcp/servers",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_info_inbox_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "inbox/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_get_sessions_inbox_sessions_get(
        self, *, search: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        search : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "inbox/sessions",
            method="GET",
            params={
                "search": search,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_get_notifications_inbox_notifications_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "inbox/notifications",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_get_session_by_id_inbox_session_id_get(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_delete_session_inbox_session_id_delete(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteResponse]:
        """
        Delete an inbox session and all its associated messages.

        Args:
            request: The FastAPI request
            session_id: The ID of the session to delete

        Returns:
            DeleteResponse with deletion status

        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteResponse,
                    construct_type(
                        type_=DeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_transcribe_inbox_session_id_transcribe_post(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/transcribe",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_private_files_inbox_session_id_files_post(
        self, session_id: str, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[FilesResponse]]:
        """
        Parameters
        ----------
        session_id : str

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[FilesResponse]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/files",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[FilesResponse],
                    construct_type(
                        type_=typing.List[FilesResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_get_session_messages_inbox_session_id_messages_get(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/messages",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_message_inbox_session_id_messages_post(
        self,
        session_id: str,
        *,
        messages: typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage],
        participants: typing.Sequence[SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem],
        history: typing.Optional[typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage]] = OMIT,
        files: typing.Optional[typing.Sequence[FilesAttribute]] = OMIT,
        mentions: typing.Optional[typing.Sequence[Mention]] = OMIT,
        ephemeral_agent_revision: typing.Optional[AgentRevision] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        session_id : str

        messages : typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage]

        participants : typing.Sequence[SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem]

        history : typing.Optional[typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage]]

        files : typing.Optional[typing.Sequence[FilesAttribute]]

        mentions : typing.Optional[typing.Sequence[Mention]]

        ephemeral_agent_revision : typing.Optional[AgentRevision]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/messages",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages,
                    annotation=typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage],
                    direction="write",
                ),
                "participants": convert_and_respect_annotation_metadata(
                    object_=participants,
                    annotation=typing.Sequence[SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem],
                    direction="write",
                ),
                "history": convert_and_respect_annotation_metadata(
                    object_=history,
                    annotation=typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage],
                    direction="write",
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Sequence[FilesAttribute], direction="write"
                ),
                "mentions": convert_and_respect_annotation_metadata(
                    object_=mentions, annotation=typing.Sequence[Mention], direction="write"
                ),
                "ephemeral_agent_revision": convert_and_respect_annotation_metadata(
                    object_=ephemeral_agent_revision, annotation=AgentRevision, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_post_session_participant_inbox_sessions_session_id_participants_post(
        self,
        session_id: str,
        *,
        request: typing.Sequence[Participant],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        session_id : str

        request : typing.Sequence[Participant]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/sessions/{jsonable_encoder(session_id)}/participants",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[Participant], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_cancel_session_inbox_session_id_cancel_post(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CancelResponse]:
        """
        Cancel ongoing agent response for a session.

        Args:
            request: The FastAPI request
            session_id: The ID of the session to cancel

        Returns:
            CancelResponse with cancellation status

        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CancelResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CancelResponse,
                    construct_type(
                        type_=CancelResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def handle_rename_session_inbox_session_id_rename_post(
        self, session_id: str, *, title: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RenameResponse]:
        """
        Rename an inbox session by updating its title.

        Args:
            request: The FastAPI request
            session_id: The ID of the session to rename
            rename_request: The request containing the new title

        Returns:
            RenameResponse with rename status and new title

        Parameters
        ----------
        session_id : str

        title : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RenameResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/rename",
            method="POST",
            json={
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RenameResponse,
                    construct_type(
                        type_=RenameResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def execute_hook_webhooks_hook_id_get(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Execute a hook trigger.

        This is the main endpoint that external services call to trigger hooks.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def execute_hook_webhooks_hook_id_post(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Execute a hook trigger.

        This is the main endpoint that external services call to trigger hooks.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_hook_webhooks_hook_id_delete(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteHookResponse]:
        """
        Soft delete a hook.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteHookResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteHookResponse,
                    construct_type(
                        type_=DeleteHookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_hook_webhooks_hook_id_patch(
        self,
        hook_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        status: typing.Optional[str] = OMIT,
        target_config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        response_mode: typing.Optional[str] = OMIT,
        allowed_methods: typing.Optional[typing.Sequence[str]] = OMIT,
        max_payload_size: typing.Optional[int] = OMIT,
        secret: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Update a hook's configuration.

        Parameters
        ----------
        hook_id : str

        name : typing.Optional[str]

        description : typing.Optional[str]

        status : typing.Optional[str]

        target_config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        response_mode : typing.Optional[str]

        allowed_methods : typing.Optional[typing.Sequence[str]]

        max_payload_size : typing.Optional[int]

        secret : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "status": status,
                "target_config": target_config,
                "response_mode": response_mode,
                "allowed_methods": allowed_methods,
                "max_payload_size": max_payload_size,
                "secret": secret,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_hooks_webhooks_get(
        self,
        *,
        target_type: typing.Optional[str] = None,
        target_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[HooksListResponse]:
        """
        List all hooks for the current organization.

        Parameters
        ----------
        target_type : typing.Optional[str]

        target_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[HooksListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks",
            method="GET",
            params={
                "target_type": target_type,
                "target_id": target_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    HooksListResponse,
                    construct_type(
                        type_=HooksListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_hook_webhooks_post(
        self, *, request: CreateHookWebhooksPostRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateHookWebhooksPostResponse]:
        """
        Create a new hook for a workflow or other target.

        Parameters
        ----------
        request : CreateHookWebhooksPostRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateHookWebhooksPostResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=CreateHookWebhooksPostRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateHookWebhooksPostResponse,
                    construct_type(
                        type_=CreateHookWebhooksPostResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_hook_webhooks_hook_id_details_get(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetHookWebhooksHookIdDetailsGetResponse]:
        """
        Get a hook by its ID.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetHookWebhooksHookIdDetailsGetResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}/details",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetHookWebhooksHookIdDetailsGetResponse,
                    construct_type(
                        type_=GetHookWebhooksHookIdDetailsGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_info_money_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingGetInfoGetInfoResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingGetInfoGetInfoResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "money",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetInfoGetInfoResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetInfoGetInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_billing_accounts_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingGetBillingResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingGetBillingResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "accounts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetBillingResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetBillingResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_usage_accounts_usage_get(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Result]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]

        end_date : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Result]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "accounts/usage",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Result,
                    construct_type(
                        type_=Result,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_invoices_accounts_invoices_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingGetInvoicesResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingGetInvoicesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "accounts/invoices",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetInvoicesResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetInvoicesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_portal_session_accounts_portal_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingCreatePortalSessionResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingCreatePortalSessionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "accounts/portal",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingCreatePortalSessionResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingCreatePortalSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_workflow_usage_accounts_usage_workflows_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "accounts/usage/workflows",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_notifications_notifications_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingGetNotificationsResponse]:
        """
        This endpoint will pull any org facing notifications for the app to display
        Mostly billing related so far

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingGetNotificationsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "notifications",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetNotificationsResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetNotificationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def change_billing_plan_accounts_plan_put(
        self, *, name: PlanTypes, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingChangeBillingPlanResponse]:
        """
        Parameters
        ----------
        name : PlanTypes

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingChangeBillingPlanResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "accounts/plan",
            method="PUT",
            json={
                "name": name,
                "interval_type": "monthly",
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingChangeBillingPlanResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingChangeBillingPlanResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def stripe_webhook_hooks_stripe_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "hooks/stripe",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def renew_plans_crons_renew_plans_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingRenewPlansResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingRenewPlansResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "crons/renew_plans",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingRenewPlansResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingRenewPlansResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def daily_billing_tasks_crons_free_plan_usage_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingFreePlanUsageResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingFreePlanUsageResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "crons/free_plan_usage",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingFreePlanUsageResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingFreePlanUsageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def billing_hourly_crons_billing_hourly_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesBillingBillingHourlyResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesBillingBillingHourlyResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "crons/billing_hourly",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingBillingHourlyResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingBillingHourlyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_spans_traces_trace_id_spans_get(
        self, trace_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        trace_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"traces/{jsonable_encoder(trace_id)}/spans",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_agent_sessions_observability_agents_agent_id_sessions_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        List agent sessions for a given agent and date range.

        Args:
            request: The FastAPI request
            agent_id: The ID of the agent
            start_date: Optional start date for filtering
            end_date: Optional end date for filtering

        Returns:
            Response with list of agent sessions

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[dt.datetime]

        end_date : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/sessions",
            method="GET",
            params={
                "start_date": serialize_datetime(start_date) if start_date is not None else None,
                "end_date": serialize_datetime(end_date) if end_date is not None else None,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_agent_sessions_summary_observability_agents_agent_id_sessions_summary_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        tool_filter: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[str]
            Start date in ISO format

        end_date : typing.Optional[str]
            End date in ISO format

        limit : typing.Optional[int]
            Number of sessions per page

        cursor : typing.Optional[str]
            Pagination cursor

        tool_filter : typing.Optional[str]
            Filter sessions by tool name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/sessions/summary",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
                "limit": limit,
                "cursor": cursor,
                "tool_filter": tool_filter,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_session_details_observability_agents_agent_id_sessions_session_id_details_get(
        self, agent_id: str, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get full session details including all traces and spans for a specific session.

        This endpoint is used when a user expands a session in the UI.

        Parameters
        ----------
        agent_id : str

        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/sessions/{jsonable_encoder(session_id)}/details",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_agent_session_analytics_observability_agents_agent_id_analytics_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get session analytics data for a specific agent from spans table (hypertable).

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[dt.datetime]

        end_date : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/analytics",
            method="GET",
            params={
                "start_date": serialize_datetime(start_date) if start_date is not None else None,
                "end_date": serialize_datetime(end_date) if end_date is not None else None,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_agent_tool_usage_observability_agents_agent_id_tool_usage_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get tool usage statistics for a specific agent.

        This endpoint aggregates tool invocations from spans data to show
        which tools are most frequently used by an agent.

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[str]
            Start date in ISO format

        end_date : typing.Optional[str]
            End date in ISO format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/tool-usage",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_agent_distinct_tools_observability_agents_agent_id_tools_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get distinct tools used by an agent.

        This endpoint returns a clean list of all tools the agent has used
        in the specified date range, with usage counts.

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[str]
            Start date in ISO format

        end_date : typing.Optional[str]
            End date in ISO format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/tools",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_pulse_feed_pulse_feed_get(
        self,
        *,
        user_id: typing.Optional[str] = None,
        agent_ids: typing.Optional[str] = None,
        action_types: typing.Optional[str] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        include_children: typing.Optional[bool] = None,
        min_significance: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PulseFeedResponse]:
        """
        Get pulse feed with enhanced filtering.

        Returns both new pulse events and legacy agent interactions.

        Parameters
        ----------
        user_id : typing.Optional[str]

        agent_ids : typing.Optional[str]

        action_types : typing.Optional[str]

        start_date : typing.Optional[str]

        end_date : typing.Optional[str]

        limit : typing.Optional[int]

        include_children : typing.Optional[bool]

        min_significance : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PulseFeedResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/feed",
            method="GET",
            params={
                "user_id": user_id,
                "agent_ids": agent_ids,
                "action_types": action_types,
                "start_date": start_date,
                "end_date": end_date,
                "limit": limit,
                "include_children": include_children,
                "min_significance": min_significance,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PulseFeedResponse,
                    construct_type(
                        type_=PulseFeedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_pulse_json_pulse_post(
        self,
        *,
        description: str,
        agents: typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]],
        action: typing.Optional[str] = OMIT,
        objects: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        context: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        visibility: typing.Optional[str] = OMIT,
        duration_minutes: typing.Optional[float] = OMIT,
        content: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        text: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreatePulseResponse]:
        """
        Create pulse from JSON data (existing endpoint)

        Parameters
        ----------
        description : str

        agents : typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]

        action : typing.Optional[str]

        objects : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]

        context : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        tags : typing.Optional[typing.Sequence[str]]

        visibility : typing.Optional[str]

        duration_minutes : typing.Optional[float]

        content : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        text : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreatePulseResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse",
            method="POST",
            json={
                "action": action,
                "description": description,
                "agents": agents,
                "objects": objects,
                "context": context,
                "tags": tags,
                "visibility": visibility,
                "duration_minutes": duration_minutes,
                "content": content,
                "text": text,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreatePulseResponse,
                    construct_type(
                        type_=CreatePulseResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_entity_activities_pulse_activities_get(
        self,
        *,
        entity_id: typing.Optional[str] = None,
        entity_type: typing.Optional[str] = None,
        involving_agent: typing.Optional[str] = None,
        on_object: typing.Optional[str] = None,
        of_type: typing.Optional[str] = None,
        with_outcome: typing.Optional[str] = None,
        since_days: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get activities - either for a specific entity or with general filters

        Parameters
        ----------
        entity_id : typing.Optional[str]
            ID of the entity

        entity_type : typing.Optional[str]
            Type of entity (account, deal, user, etc)

        involving_agent : typing.Optional[str]

        on_object : typing.Optional[str]

        of_type : typing.Optional[str]

        with_outcome : typing.Optional[str]

        since_days : typing.Optional[int]

        limit : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/activities",
            method="GET",
            params={
                "entity_id": entity_id,
                "entity_type": entity_type,
                "involving_agent": involving_agent,
                "on_object": on_object,
                "of_type": of_type,
                "with_outcome": with_outcome,
                "since_days": since_days,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_create_pulse_store_create_post(
        self,
        *,
        type: str,
        data: typing.Dict[str, typing.Optional[typing.Any]],
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StoreResponse]:
        """
        Create a new entity.

        Example:
            POST /pulse/store/create
            {
                "type": "todo",
                "data": {
                    "title": "Buy milk",
                    "completed": false
                }
            }

        Parameters
        ----------
        type : str
            Entity type (e.g., 'todo', 'note', 'task')

        data : typing.Dict[str, typing.Optional[typing.Any]]
            Entity data

        tags : typing.Optional[typing.Sequence[str]]
            Optional tags

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/create",
            method="POST",
            json={
                "type": type,
                "data": data,
                "tags": tags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_update_pulse_store_update_post(
        self,
        *,
        id: str,
        updates: typing.Dict[str, typing.Optional[typing.Any]],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StoreResponse]:
        """
        Update an entity (partial updates).

        Example:
            POST /pulse/store/update
            {
                "id": "todo_abc123",
                "updates": {
                    "completed": true,
                    "completed_at": "2024-01-01T12:00:00Z"
                }
            }

        Parameters
        ----------
        id : str
            Entity ID

        updates : typing.Dict[str, typing.Optional[typing.Any]]
            Partial updates to apply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/update",
            method="POST",
            json={
                "id": id,
                "updates": updates,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_get_tags_pulse_store_tags_get(
        self,
        *,
        type: typing.Optional[str] = None,
        prefix: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TagsResponse]:
        """
        Get all unique tags across entities.

        Example:
            GET /pulse/store/tags?type=file&prefix=folder:

        Parameters
        ----------
        type : typing.Optional[str]

        prefix : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TagsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/tags",
            method="GET",
            params={
                "type": type,
                "prefix": prefix,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagsResponse,
                    construct_type(
                        type_=TagsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_update_tags_pulse_store_tags_update_post(
        self,
        *,
        id: str,
        add_tags: typing.Optional[typing.Sequence[str]] = OMIT,
        remove_tags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StoreResponse]:
        """
        Add or remove tags from an entity.

        Example:
            POST /pulse/store/tags/update
            {
                "id": "file-uuid",
                "add_tags": ["folder:marketing", "folder:campaigns"],
                "remove_tags": ["folder:archive"]
            }

        Parameters
        ----------
        id : str
            Entity ID

        add_tags : typing.Optional[typing.Sequence[str]]
            Tags to add

        remove_tags : typing.Optional[typing.Sequence[str]]
            Tags to remove

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/tags/update",
            method="POST",
            json={
                "id": id,
                "add_tags": add_tags,
                "remove_tags": remove_tags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_get_pulse_store_entity_id_get(
        self, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StoreResponse]:
        """
        Get a single entity.

        GET /pulse/store/{entity_id}

        Parameters
        ----------
        entity_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/store/{jsonable_encoder(entity_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_delete_pulse_store_entity_id_delete(
        self,
        entity_id: str,
        *,
        soft: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StoreResponse]:
        """
        Delete an entity.

        DELETE /pulse/store/{entity_id}?soft=true

        Parameters
        ----------
        entity_id : str

        soft : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/store/{jsonable_encoder(entity_id)}",
            method="DELETE",
            params={
                "soft": soft,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_query_pulse_store_query_post(
        self,
        *,
        type: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        limit: typing.Optional[int] = OMIT,
        include_deleted: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StoreResponse]:
        """
        Query entities with filters.

        Example:
            POST /pulse/store/query
            {
                "type": "file",
                "tags": ["folder:marketing"],
                "filter": {
                    "completed": false
                },
                "limit": 50
            }

        Parameters
        ----------
        type : typing.Optional[str]
            Filter by entity type

        filter : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Filter by data fields

        tags : typing.Optional[typing.Sequence[str]]
            Filter by tags (must have ALL specified tags)

        limit : typing.Optional[int]
            Max results

        include_deleted : typing.Optional[bool]
            Include soft-deleted entities

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/query",
            method="POST",
            json={
                "type": type,
                "filter": filter,
                "tags": tags,
                "limit": limit,
                "include_deleted": include_deleted,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_query_fluent_pulse_store_query_fluent_post(
        self,
        *,
        select: str,
        where: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        with_: typing.Optional[typing.Sequence[FluentQueryRequestWithItem]] = OMIT,
        order_by: typing.Optional[typing.Sequence[typing.Dict[str, str]]] = OMIT,
        limit: typing.Optional[int] = OMIT,
        offset: typing.Optional[int] = OMIT,
        cursor: typing.Optional[str] = OMIT,
        count: typing.Optional[bool] = OMIT,
        group_by: typing.Optional[str] = OMIT,
        aggregations: typing.Optional[typing.Dict[str, typing.Dict[str, str]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Powerful fluent query API with relationships and advanced filtering.

        Example:
            POST /pulse/store/query/fluent
            {
                "select": "deal",
                "where": [
                    {"field": "stage", "operator": "in", "value": ["negotiation", "proposal"]},
                    {"field": "value", "operator": ">=", "value": 50000}
                ],
                "with": ["account", "contact"],
                "orderBy": [{"field": "value", "direction": "desc"}],
                "limit": 50
            }

        Returns:
            {
                "ok": true,
                "data": [entity, ...],
                "total": 123,
                "includes": {
                    "account": {entity_id: account_entity},
                    "contact": {entity_id: contact_entity}
                }
            }

        Parameters
        ----------
        select : str
            Entity type to select

        where : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            WHERE conditions: [{field, operator, value}, ...]

        with_ : typing.Optional[typing.Sequence[FluentQueryRequestWithItem]]
            Relations to include (auto-JOIN)

        order_by : typing.Optional[typing.Sequence[typing.Dict[str, str]]]
            Order by: [{field, direction}, ...]

        limit : typing.Optional[int]
            Max results

        offset : typing.Optional[int]
            Offset for pagination

        cursor : typing.Optional[str]
            Cursor for pagination

        count : typing.Optional[bool]
            Include total count

        group_by : typing.Optional[str]
            Group by field

        aggregations : typing.Optional[typing.Dict[str, typing.Dict[str, str]]]
            Aggregations: {alias: {function, field}}

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/query/fluent",
            method="POST",
            json={
                "select": select,
                "where": where,
                "with": convert_and_respect_annotation_metadata(
                    object_=with_, annotation=typing.Sequence[FluentQueryRequestWithItem], direction="write"
                ),
                "orderBy": order_by,
                "limit": limit,
                "offset": offset,
                "cursor": cursor,
                "count": count,
                "groupBy": group_by,
                "aggregations": aggregations,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def store_batch_create_pulse_store_batch_create_post(
        self, *, entities: typing.Sequence[CreateEntityRequest], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StoreResponse]:
        """
        Create multiple entities.

        Example:
            POST /pulse/store/batch/create
            {
                "entities": [
                    {"type": "todo", "data": {"title": "Task 1"}},
                    {"type": "todo", "data": {"title": "Task 2"}}
                ]
            }

        Parameters
        ----------
        entities : typing.Sequence[CreateEntityRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StoreResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/store/batch/create",
            method="POST",
            json={
                "entities": convert_and_respect_annotation_metadata(
                    object_=entities, annotation=typing.Sequence[CreateEntityRequest], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_entities_pulse_entities_get(
        self,
        *,
        limit: typing.Optional[int] = None,
        entity_type: typing.Optional[str] = None,
        current_state: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        List all entities extracted from activities.

        Returns entities with their mention counts and metadata.
        Used by the frontend ChannelEntitiesPanel.

        Parameters
        ----------
        limit : typing.Optional[int]

        entity_type : typing.Optional[str]
            Filter by entity type

        current_state : typing.Optional[bool]
            Return only current state via quantum collapse

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/entities",
            method="GET",
            params={
                "limit": limit,
                "entity_type": entity_type,
                "current_state": current_state,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_entities_pulse_entities_query_post(
        self,
        *,
        entity_type: typing.Optional[str] = OMIT,
        activity_filters: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        outcomes: typing.Optional[typing.Sequence[str]] = OMIT,
        actions: typing.Optional[typing.Sequence[str]] = OMIT,
        time: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        kinds: typing.Optional[typing.Sequence[str]] = OMIT,
        roles: typing.Optional[typing.Sequence[str]] = OMIT,
        current_state: typing.Optional[bool] = OMIT,
        include_stats: typing.Optional[bool] = OMIT,
        group_by: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        min_activities: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Query entities (agents or objects) across activities

        Examples:

        # Find all sales agents
        {
            "entity_type": "agent",
            "tags": ["sales"],
            "include_stats": true
        }

        # Find documents involved in approved deals
        {
            "entity_type": "object",
            "kinds": ["document", "contract"],
            "outcomes": ["approved"],
            "include_stats": true
        }

        # Find active users in last 7 days
        {
            "entity_type": "agent",
            "kinds": ["user"],
            "time": {"last": "7d"},
            "min_activities": 5,
            "include_stats": true
        }

        # Find cross-functional agents (sales + engineering)
        {
            "entity_type": "agent",
            "tags": ["sales", "engineering"],
            "group_by": "kind"
        }

        Parameters
        ----------
        entity_type : typing.Optional[str]
            'agent' or 'object'

        activity_filters : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Filter activities that entities appear in

        tags : typing.Optional[typing.Sequence[str]]
            Activities must have these tags

        outcomes : typing.Optional[typing.Sequence[str]]
            Activities must have these outcomes

        actions : typing.Optional[typing.Sequence[str]]
            Activities must have these actions

        time : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Time range for activities

        kinds : typing.Optional[typing.Sequence[str]]
            Entity kinds to include (user, team, document, etc)

        roles : typing.Optional[typing.Sequence[str]]
            Entity roles to include

        current_state : typing.Optional[bool]
            Return only current state via quantum collapse

        include_stats : typing.Optional[bool]
            Include activity statistics for each entity

        group_by : typing.Optional[str]
            Group entities by field (kind, role)

        limit : typing.Optional[int]

        min_activities : typing.Optional[int]
            Minimum activities for entity to be included

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/entities/query",
            method="POST",
            json={
                "entity_type": entity_type,
                "activity_filters": activity_filters,
                "tags": tags,
                "outcomes": outcomes,
                "actions": actions,
                "time": time,
                "kinds": kinds,
                "roles": roles,
                "current_state": current_state,
                "include_stats": include_stats,
                "group_by": group_by,
                "limit": limit,
                "min_activities": min_activities,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_entity_network_pulse_entities_entity_id_network_get(
        self,
        entity_id: str,
        *,
        depth: typing.Optional[int] = None,
        min_interactions: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get the collaboration network around an entity

        Returns entities connected to the target entity through shared activities

        Parameters
        ----------
        entity_id : str

        depth : typing.Optional[int]
            Network depth

        min_interactions : typing.Optional[int]
            Minimum interactions to include connection

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/entities/{jsonable_encoder(entity_id)}/network",
            method="GET",
            params={
                "depth": depth,
                "min_interactions": min_interactions,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_entity_network_pg_pulse_entities_entity_id_network_pg_get(
        self,
        entity_id: str,
        *,
        depth: typing.Optional[int] = None,
        min_interactions: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get the collaboration network around an entity using PostgreSQL.

        Returns entities connected to the target entity through shared activities.
        This is optimized for PostgreSQL and uses efficient SQL queries instead of
        multiple API calls.

        Parameters
        ----------
        entity_id : str

        depth : typing.Optional[int]
            Network depth

        min_interactions : typing.Optional[int]
            Minimum interactions to include connection

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/entities/{jsonable_encoder(entity_id)}/network/pg",
            method="GET",
            params={
                "depth": depth,
                "min_interactions": min_interactions,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_entity_details_pulse_entities_entity_type_entity_id_get(
        self,
        entity_type: str,
        entity_id: str,
        *,
        include_activities: typing.Optional[bool] = None,
        time_range: typing.Optional[str] = None,
        current_state: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get detailed information about a specific entity

        When current_state=true, uses quantum collapse to return only the latest state.
        Otherwise includes all activities they've been involved in and collaboration patterns.

        Parameters
        ----------
        entity_type : str

        entity_id : str

        include_activities : typing.Optional[bool]

        time_range : typing.Optional[str]
            Time range like '7d', '30d'

        current_state : typing.Optional[bool]
            Return only current state via quantum collapse

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/entities/{jsonable_encoder(entity_type)}/{jsonable_encoder(entity_id)}",
            method="GET",
            params={
                "include_activities": include_activities,
                "time_range": time_range,
                "current_state": current_state,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_schemas_pulse_schemas_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SchemasResponse]:
        """
        Get all schemas for dynamic form generation.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SchemasResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/schemas",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SchemasResponse,
                    construct_type(
                        type_=SchemasResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_activities_pulse_search_post(
        self,
        *,
        query: typing.Optional[str] = OMIT,
        search_type: typing.Optional[SearchRequestSearchType] = OMIT,
        filters: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        limit: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Hybrid search for activities using PostgreSQL full-text and vector search.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        query : typing.Optional[str]
            Search query text

        search_type : typing.Optional[SearchRequestSearchType]
            Type of search

        filters : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Additional filters to apply

        limit : typing.Optional[int]
            Maximum results to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/search",
            method="POST",
            json={
                "query": query,
                "search_type": search_type,
                "filters": filters,
                "limit": limit,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_entities_pulse_search_entities_post(
        self,
        *,
        query: str,
        entity_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        entity_types: typing.Optional[typing.Sequence[str]] = OMIT,
        mode: typing.Optional[EntitySearchRequestMode] = OMIT,
        return_format: typing.Optional[EntitySearchRequestReturnFormat] = OMIT,
        limit: typing.Optional[int] = OMIT,
        similarity_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Search for entities with document content using hybrid search.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        query : str
            Search query text

        entity_ids : typing.Optional[typing.Sequence[str]]
            Specific entity IDs to search within

        entity_types : typing.Optional[typing.Sequence[str]]
            Entity types to search (file, note, etc)

        mode : typing.Optional[EntitySearchRequestMode]
            Search mode

        return_format : typing.Optional[EntitySearchRequestReturnFormat]
            What to return - chunks, entity info, or full text

        limit : typing.Optional[int]
            Max results

        similarity_threshold : typing.Optional[float]
            Minimum similarity score

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/search/entities",
            method="POST",
            json={
                "query": query,
                "entity_ids": entity_ids,
                "entity_types": entity_types,
                "mode": mode,
                "return_format": return_format,
                "limit": limit,
                "similarity_threshold": similarity_threshold,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_search_indexes_pulse_search_update_indexes_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Update search indexes for existing activities.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/search/update-indexes",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_distinct_values_pulse_search_distinct_field_get(
        self, field: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get distinct values for a specific field to help with query building.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        field : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/search/distinct/{jsonable_encoder(field)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_builder_pulse_query_post(
        self,
        *,
        limit: typing.Optional[int] = OMIT,
        offset: typing.Optional[int] = OMIT,
        text_query: typing.Optional[str] = OMIT,
        time_range_start: typing.Optional[dt.datetime] = OMIT,
        time_range_end: typing.Optional[dt.datetime] = OMIT,
        last_hours: typing.Optional[int] = OMIT,
        last_days: typing.Optional[int] = OMIT,
        agent_types: typing.Optional[typing.Sequence[str]] = OMIT,
        agent_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        object_types: typing.Optional[typing.Sequence[str]] = OMIT,
        object_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        action_types: typing.Optional[typing.Sequence[str]] = OMIT,
        action_statuses: typing.Optional[typing.Sequence[str]] = OMIT,
        specific_actions: typing.Optional[typing.Sequence[str]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        exclude_tags: typing.Optional[typing.Sequence[str]] = OMIT,
        tag_mode: typing.Optional[QueryBuilderRequestTagMode] = OMIT,
        min_duration_minutes: typing.Optional[float] = OMIT,
        max_duration_minutes: typing.Optional[float] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        team_name: typing.Optional[str] = OMIT,
        deal_stages: typing.Optional[typing.Sequence[str]] = OMIT,
        revenue_impact: typing.Optional[bool] = OMIT,
        churn_risk: typing.Optional[bool] = OMIT,
        escalation_level: typing.Optional[str] = OMIT,
        trace_id: typing.Optional[str] = OMIT,
        triggered_by: typing.Optional[str] = OMIT,
        sort_by: typing.Optional[QueryBuilderRequestSortBy] = OMIT,
        sort_direction: typing.Optional[QueryBuilderRequestSortDirection] = OMIT,
        count_only: typing.Optional[bool] = OMIT,
        explain: typing.Optional[bool] = OMIT,
        aggregate: typing.Optional[bool] = OMIT,
        group_by: typing.Optional[typing.Sequence[QueryBuilderRequestGroupByItem]] = OMIT,
        group_by_tag_prefix: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Execute a declarative query using the powerful PulseQuery builder

        This endpoint provides a more structured and powerful alternative to text-based search,
        allowing complex filtering, aggregation, and business logic queries.

        Examples:

        # Find all activities by specific agents in last 7 days
        {
            "agent_types": ["user"],
            "last_days": 7,
            "sort_by": "time"
        }

        # Customer journey analysis
        {
            "customer_id": "customer_123",
            "last_days": 30,
            "sort_by": "time",
            "sort_direction": "asc"
        }

        # Revenue impact events with duration filters
        {
            "revenue_impact": true,
            "min_duration_minutes": 5,
            "tags": ["sales", "deal"],
            "tag_mode": "all"
        }

        # Aggregated metrics by team
        {
            "last_days": 14,
            "aggregate": true,
            "group_by": ["agent_type"],
            "team_name": "engineering"
        }

        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum results to return

        offset : typing.Optional[int]
            Offset for pagination

        text_query : typing.Optional[str]
            Text to search in descriptions

        time_range_start : typing.Optional[dt.datetime]
            Start time for filtering

        time_range_end : typing.Optional[dt.datetime]
            End time for filtering

        last_hours : typing.Optional[int]
            Filter to last N hours

        last_days : typing.Optional[int]
            Filter to last N days

        agent_types : typing.Optional[typing.Sequence[str]]
            Filter by agent types

        agent_ids : typing.Optional[typing.Sequence[str]]
            Filter by specific agent IDs

        object_types : typing.Optional[typing.Sequence[str]]
            Filter by object types

        object_ids : typing.Optional[typing.Sequence[str]]
            Filter by specific object IDs

        action_types : typing.Optional[typing.Sequence[str]]
            Filter by action types

        action_statuses : typing.Optional[typing.Sequence[str]]
            Filter by action statuses

        specific_actions : typing.Optional[typing.Sequence[str]]
            Filter by specific action names

        tags : typing.Optional[typing.Sequence[str]]
            Tags to include

        exclude_tags : typing.Optional[typing.Sequence[str]]
            Tags to exclude

        tag_mode : typing.Optional[QueryBuilderRequestTagMode]
            Whether to match any or all tags

        min_duration_minutes : typing.Optional[float]
            Minimum duration in minutes

        max_duration_minutes : typing.Optional[float]
            Maximum duration in minutes

        customer_id : typing.Optional[str]
            Filter by customer ID

        team_name : typing.Optional[str]
            Filter by team

        deal_stages : typing.Optional[typing.Sequence[str]]
            Filter by deal stages

        revenue_impact : typing.Optional[bool]
            Filter for revenue impact events

        churn_risk : typing.Optional[bool]
            Filter for churn risk events

        escalation_level : typing.Optional[str]
            Filter by escalation level

        trace_id : typing.Optional[str]
            Filter by trace ID

        triggered_by : typing.Optional[str]
            Filter by triggering event

        sort_by : typing.Optional[QueryBuilderRequestSortBy]
            Sort field

        sort_direction : typing.Optional[QueryBuilderRequestSortDirection]
            Sort direction

        count_only : typing.Optional[bool]
            Return only count, not full results

        explain : typing.Optional[bool]
            Include query explanation

        aggregate : typing.Optional[bool]
            Return aggregated results

        group_by : typing.Optional[typing.Sequence[QueryBuilderRequestGroupByItem]]
            Group by fields for aggregation

        group_by_tag_prefix : typing.Optional[str]
            Group by tag prefix (e.g., 'customer:')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/query",
            method="POST",
            json={
                "limit": limit,
                "offset": offset,
                "text_query": text_query,
                "time_range_start": time_range_start,
                "time_range_end": time_range_end,
                "last_hours": last_hours,
                "last_days": last_days,
                "agent_types": agent_types,
                "agent_ids": agent_ids,
                "object_types": object_types,
                "object_ids": object_ids,
                "action_types": action_types,
                "action_statuses": action_statuses,
                "specific_actions": specific_actions,
                "tags": tags,
                "exclude_tags": exclude_tags,
                "tag_mode": tag_mode,
                "min_duration_minutes": min_duration_minutes,
                "max_duration_minutes": max_duration_minutes,
                "customer_id": customer_id,
                "team_name": team_name,
                "deal_stages": deal_stages,
                "revenue_impact": revenue_impact,
                "churn_risk": churn_risk,
                "escalation_level": escalation_level,
                "trace_id": trace_id,
                "triggered_by": triggered_by,
                "sort_by": sort_by,
                "sort_direction": sort_direction,
                "count_only": count_only,
                "explain": explain,
                "aggregate": aggregate,
                "group_by": group_by,
                "group_by_tag_prefix": group_by_tag_prefix,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_builder_schema_pulse_query_schema_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get the schema for the query builder, showing all available filters and options

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/query/schema",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_pulse_files_stream_pulse_files_stream_post(
        self, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Upload files to Pulse with activity tracking and optional RAG processing.
        Returns a streaming response with progress updates.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/files/stream",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_pulse_files_pulse_files_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get list of files for an organization.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/files",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def download_pulse_file_pulse_files_file_name_get(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get a signed URL for downloading a file.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/files/{jsonable_encoder(file_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_pulse_file_pulse_files_file_name_delete(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Delete a file and its associated chunks.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/files/{jsonable_encoder(file_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_file_chunks_pulse_files_file_name_chunks_get(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get RAG document chunks for a file.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/files/{jsonable_encoder(file_name)}/chunks",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_ai_suggestion_pulse_security_questionnaire_ai_suggest_post(
        self,
        *,
        question_id: str,
        question_text: str,
        category: str,
        questionnaire_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Generate AI suggestion for a security question using RAG.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        question_id : str

        question_text : str

        category : str

        questionnaire_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/security-questionnaire/ai-suggest",
            method="POST",
            json={
                "question_id": question_id,
                "question_text": question_text,
                "category": category,
                "questionnaire_id": questionnaire_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_batch_suggestions_pulse_security_questionnaire_batch_suggest_post(
        self,
        *,
        question_ids: typing.Sequence[str],
        questionnaire_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Generate AI suggestions for multiple questions in batch.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        question_ids : typing.Sequence[str]

        questionnaire_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "pulse/security-questionnaire/batch-suggest",
            method="POST",
            json={
                "question_ids": question_ids,
                "questionnaire_id": questionnaire_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_questionnaire_files_pulse_security_questionnaire_questionnaire_id_files_put(
        self,
        questionnaire_id: str,
        *,
        file_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Update the selected files for a questionnaire.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        questionnaire_id : str

        file_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/security-questionnaire/{jsonable_encoder(questionnaire_id)}/files",
            method="PUT",
            json={
                "file_ids": file_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_questionnaire_with_questions_pulse_security_questionnaire_questionnaire_id_get(
        self, questionnaire_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Get questionnaire with all its questions loaded.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        questionnaire_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pulse/security-questionnaire/{jsonable_encoder(questionnaire_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def seed_agents_onboarding_seed_agents_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Manually seed default agent personas for a new organization.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "onboarding/seed-agents",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def find_me_me_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SrcAppHttpRoutesOnboardingHandleGetMeResponse]:
        """
        Get the current authenticated user's information.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesOnboardingHandleGetMeResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "me",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesOnboardingHandleGetMeResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesOnboardingHandleGetMeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_me_me_put(
        self,
        *,
        favorites: typing.Optional[typing.Sequence[FavoriteRef]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SrcAppHttpRoutesOnboardingHandleUpdateMeResponse]:
        """
        Update the current authenticated user's information.

        Parameters
        ----------
        favorites : typing.Optional[typing.Sequence[FavoriteRef]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SrcAppHttpRoutesOnboardingHandleUpdateMeResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "me",
            method="PUT",
            json={
                "favorites": convert_and_respect_annotation_metadata(
                    object_=favorites, annotation=typing.Sequence[FavoriteRef], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesOnboardingHandleUpdateMeResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesOnboardingHandleUpdateMeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def find_all_scout_hooks_hooks_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ScoutHooksResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ScoutHooksResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "hooks",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScoutHooksResponse,
                    construct_type(
                        type_=ScoutHooksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_scout_hook_hooks_post(
        self,
        *,
        hook_config: typing.Optional[ScoutHookConfigHttp] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        triggering_events: typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ScoutHookResponse]:
        """
        Parameters
        ----------
        hook_config : typing.Optional[ScoutHookConfigHttp]

        name : typing.Optional[str]

        description : typing.Optional[str]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        triggering_events : typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ScoutHookResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "hooks",
            method="POST",
            json={
                "hook_config": convert_and_respect_annotation_metadata(
                    object_=hook_config, annotation=ScoutHookConfigHttp, direction="write"
                ),
                "name": name,
                "description": description,
                "metadata": metadata,
                "triggering_events": convert_and_respect_annotation_metadata(
                    object_=triggering_events,
                    annotation=typing.Sequence[ScoutHookUpdateTriggeringEventsItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScoutHookResponse,
                    construct_type(
                        type_=ScoutHookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_scout_hook_hooks_hook_id_put(
        self,
        hook_id: str,
        *,
        hook_config: typing.Optional[ScoutHookConfigHttp] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        triggering_events: typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ScoutHookResponse]:
        """
        Parameters
        ----------
        hook_id : str

        hook_config : typing.Optional[ScoutHookConfigHttp]

        name : typing.Optional[str]

        description : typing.Optional[str]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        triggering_events : typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ScoutHookResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"hooks/{jsonable_encoder(hook_id)}",
            method="PUT",
            json={
                "hook_config": convert_and_respect_annotation_metadata(
                    object_=hook_config, annotation=ScoutHookConfigHttp, direction="write"
                ),
                "name": name,
                "description": description,
                "metadata": metadata,
                "triggering_events": convert_and_respect_annotation_metadata(
                    object_=triggering_events,
                    annotation=typing.Sequence[ScoutHookUpdateTriggeringEventsItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScoutHookResponse,
                    construct_type(
                        type_=ScoutHookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_scout_hook_hooks_hook_id_delete(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"hooks/{jsonable_encoder(hook_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def rotate_api_keys_organization_rotate_keys_post(
        self,
        *,
        confirm: typing.Optional[bool] = OMIT,
        grace_period_hours: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Rotate API keys for the current organization.

        Delegates to ProfileManager for the actual business logic.

        Parameters
        ----------
        confirm : typing.Optional[bool]

        grace_period_hours : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "organization/rotate-keys",
            method="POST",
            json={
                "confirm": confirm,
                "grace_period_hours": grace_period_hours,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_tags_tags_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListTagsResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListTagsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tags",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListTagsResponse,
                    construct_type(
                        type_=ListTagsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_tag_tags_post(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateTagResponse]:
        """
        Parameters
        ----------
        name : str

        description : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateTagResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tags",
            method="POST",
            json={
                "name": name,
                "description": description,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateTagResponse,
                    construct_type(
                        type_=CreateTagResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_tag_tags_tag_id_get(
        self, tag_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Tag]:
        """
        Parameters
        ----------
        tag_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Tag]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tags/{jsonable_encoder(tag_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tag,
                    construct_type(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_tag_tags_tag_id_put(
        self,
        tag_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateTagResponse]:
        """
        Parameters
        ----------
        tag_id : str

        name : typing.Optional[str]

        description : typing.Optional[str]

        active : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateTagResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tags/{jsonable_encoder(tag_id)}",
            method="PUT",
            json={
                "name": name,
                "description": description,
                "active": active,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateTagResponse,
                    construct_type(
                        type_=UpdateTagResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_tools_tools_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListToolsResponse]:
        """
        Get available tools for the organization with full input schemas.

        This endpoint delegates to the Tool domain API which provides:
        - Tool authorization checking
        - Schema retrieval from all sources
        - Comprehensive tool information

        Args:
            request: The FastAPI request

        Returns:
            ListToolsResponse with detailed tool information

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListToolsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListToolsResponse,
                    construct_type(
                        type_=ListToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_tool_tools_tool_name_get(
        self, tool_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ToolDetails]:
        """
        Get detailed information about a specific tool.

        This endpoint returns comprehensive information about a single tool including:
        - Tool metadata (name, description, icon)
        - Input schema
        - Labels and categorization

        Args:
            request: The FastAPI request
            tool_name: The name of the tool to retrieve

        Returns:
            ToolDetails with comprehensive tool information

        Raises:
            HTTPException: 404 if tool not found, 403 if not available

        Parameters
        ----------
        tool_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolDetails]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(tool_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolDetails,
                    construct_type(
                        type_=ToolDetails,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def execute_tool_tools_tool_name_execute_post(
        self,
        tool_name: str,
        *,
        input_data: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ExecuteToolResponse]:
        """
        Execute a specific tool.

        This endpoint delegates to the Tool domain API which handles:
        - Tool authorization
        - Tool discovery from all sources
        - Context injection
        - Tool execution

        Args:
            request: The FastAPI request
            tool_name: The name of the tool to execute (from path parameter)
            body: The tool execution request body

        Returns:
            ExecuteToolResponse with execution result or error

        Parameters
        ----------
        tool_name : str

        input_data : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input data for the tool execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ExecuteToolResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(tool_name)}/execute",
            method="POST",
            json={
                "input_data": input_data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExecuteToolResponse,
                    construct_type(
                        type_=ExecuteToolResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def interact_handler_world_agent_id_session_id_interact_post(
        self,
        agent_id: str,
        session_id: str,
        *,
        messages: typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        session_id : str

        messages : typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"world/{jsonable_encoder(agent_id)}/{jsonable_encoder(session_id)}/_interact",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages,
                    annotation=typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def interact_handler_world_agent_id_interact_post(
        self,
        agent_id: str,
        *,
        messages: typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
        session_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        messages : typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage]

        session_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"world/{jsonable_encoder(agent_id)}/_interact",
            method="POST",
            params={
                "session_id": session_id,
            },
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages,
                    annotation=typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_agents_agents_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_agent_agents_post(
        self,
        *,
        agent: str,
        revision: str,
        agent_image: core.File,
        agent_id: typing.Optional[str] = OMIT,
        activate: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent : str

        revision : str

        agent_image : core.File
            See core.File for more documentation

        agent_id : typing.Optional[str]

        activate : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="POST",
            data={
                "agent": agent,
                "agent_id": agent_id,
                "activate": activate,
                "revision": revision,
            },
            files={
                "agent_image": agent_image,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_active_agent_agents_agent_id_active_get(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Retrieve an agent and its active revision by agent_id.
        Verifies that the agent belongs to the actor's organization.

        Parameters
        ----------
        agent_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/active",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_tools_agents_tools_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ToolsResponse]:
        """
        Get available tools for the organization.

        Args:
            request: The FastAPI request

        Returns:
            Span with the list of available tools attached to its attributes

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/tools",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsResponse,
                    construct_type(
                        type_=ToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_agent_agents_agent_id_delete(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def expire_blobs_expire_blobs_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "_expire_blobs",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_drive_drive_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "drive",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_drive_file_drive_files_file_name_get(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"drive/files/{jsonable_encoder(file_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_files_to_drive_drive_files_post(
        self, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "drive/files",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_drive_crawl_drive_crawls_post(
        self,
        *,
        source_sync_settings: SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings,
        url: str,
        schedule: typing.Optional[Schedule] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Since we do not have domain apis for collections we have to import
        the route functions and pass the request through.

        We could get the org key and move this logic to the drive domain api
        but we would then need to get the org secret key to make http requests
        since importing into the drive domain api would cause circular dependencies.
        Which then forces us to use network requests via scout sdk or httpx.

        This is the lesser evil I.M.O.

        Parameters
        ----------
        source_sync_settings : SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings

        url : str

        schedule : typing.Optional[Schedule]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "drive/crawls",
            method="POST",
            json={
                "source_sync_settings": convert_and_respect_annotation_metadata(
                    object_=source_sync_settings,
                    annotation=SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings,
                    direction="write",
                ),
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=Schedule, direction="write"
                ),
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def grant_access_drive_grant_post(
        self,
        *,
        agent_ids: typing.Sequence[str],
        resources: typing.Sequence[Resource],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_ids : typing.Sequence[str]

        resources : typing.Sequence[Resource]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "drive/grant",
            method="POST",
            json={
                "agent_ids": agent_ids,
                "resources": convert_and_respect_annotation_metadata(
                    object_=resources, annotation=typing.Sequence[Resource], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def revoke_access_drive_revoke_post(
        self,
        *,
        agent_ids: typing.Sequence[str],
        resource_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_ids : typing.Sequence[str]

        resource_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "drive/revoke",
            method="POST",
            json={
                "agent_ids": agent_ids,
                "resource_ids": resource_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawScout:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def info_handler_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesRootGetInfoResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesRootGetInfoResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesRootGetInfoResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesRootGetInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_info_v_2_triggers_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/triggers/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_info_v_2_index_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/index/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_info_v_2_workflows_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/workflows/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_info_v_2_collections_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/collections/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def parse_file_v_2_files_parse_post(
        self,
        *,
        file: core.File,
        return_text: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SrcAppHttpRoutesCollectionParseFileResponse]:
        """
        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        return_text : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesCollectionParseFileResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/files/parse",
            method="POST",
            params={
                "return_text": return_text,
            },
            data={},
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesCollectionParseFileResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesCollectionParseFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_integrations_integrations_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[IntegrationWithConnections]]:
        """
        Get all integrations for an organization

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[IntegrationWithConnections]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[IntegrationWithConnections],
                    construct_type(
                        type_=typing.List[IntegrationWithConnections],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_integration_integrations_integration_id_get(
        self, integration_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[IntegrationWithConnections]:
        """
        Get a specific integration for an organization by its ID.

        Parameters
        ----------
        integration_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IntegrationWithConnections]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"integrations/{jsonable_encoder(integration_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IntegrationWithConnections,
                    construct_type(
                        type_=IntegrationWithConnections,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_integration_connections_integrations_integration_id_connections_get(
        self, integration_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[IntegrationConnection]]:
        """
        Get all integrations for an organization

        Parameters
        ----------
        integration_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[IntegrationConnection]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"integrations/{jsonable_encoder(integration_id)}/connections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[IntegrationConnection],
                    construct_type(
                        type_=typing.List[IntegrationConnection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def connect_integration_integrations_integration_id_connect_post(
        self,
        integration_id: str,
        *,
        auth_type: ConnectIntegrationRequestAuthType,
        api_key: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        state: typing.Optional[str] = OMIT,
        scope: typing.Optional[str] = OMIT,
        client_id: typing.Optional[str] = OMIT,
        client_secret: typing.Optional[str] = OMIT,
        environment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateIntegrationsResponse]:
        """
        Parameters
        ----------
        integration_id : str

        auth_type : ConnectIntegrationRequestAuthType

        api_key : typing.Optional[str]

        code : typing.Optional[str]

        state : typing.Optional[str]

        scope : typing.Optional[str]

        client_id : typing.Optional[str]

        client_secret : typing.Optional[str]

        environment : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateIntegrationsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"integrations/{jsonable_encoder(integration_id)}/connect",
            method="POST",
            json={
                "auth_type": auth_type,
                "api_key": api_key,
                "code": code,
                "state": state,
                "scope": scope,
                "client_id": client_id,
                "client_secret": client_secret,
                "environment": environment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateIntegrationsResponse,
                    construct_type(
                        type_=CreateIntegrationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_send_message_integrations_slack_send_post(
        self,
        *,
        channel_id: str,
        text: str,
        thread_id: typing.Optional[str] = OMIT,
        blocks: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        username: typing.Optional[str] = OMIT,
        icon_url: typing.Optional[str] = OMIT,
        integration_id: typing.Optional[str] = OMIT,
        unfurl_links: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        channel_id : str

        text : str

        thread_id : typing.Optional[str]

        blocks : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]

        username : typing.Optional[str]

        icon_url : typing.Optional[str]

        integration_id : typing.Optional[str]

        unfurl_links : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/slack/send",
            method="POST",
            json={
                "channel_id": channel_id,
                "text": text,
                "thread_id": thread_id,
                "blocks": blocks,
                "username": username,
                "icon_url": icon_url,
                "integration_id": integration_id,
                "unfurl_links": unfurl_links,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_add_reaction_integrations_slack_react_post(
        self,
        *,
        channel_id: str,
        emoji_name: str,
        thread_id: typing.Optional[str] = OMIT,
        integration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        channel_id : str

        emoji_name : str

        thread_id : typing.Optional[str]

        integration_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/slack/react",
            method="POST",
            json={
                "channel_id": channel_id,
                "emoji_name": emoji_name,
                "thread_id": thread_id,
                "integration_id": integration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_get_thread_integrations_slack_thread_get(
        self,
        *,
        channel_id: str,
        thread_id: str,
        integration_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        channel_id : str

        thread_id : str

        integration_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/slack/thread",
            method="GET",
            params={
                "channel_id": channel_id,
                "thread_id": thread_id,
                "integration_id": integration_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_get_team_info_integrations_slack_team_get(
        self, *, team_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Handles the request to get Slack team info

        Parameters
        ----------
        team_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/slack/team",
            method="GET",
            params={
                "team_id": team_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_list_channels_integrations_slack_channels_get(
        self,
        *,
        team_id: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        team_id : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/slack/channels",
            method="GET",
            params={
                "team_id": team_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_migrate_integrations_integrations_migrate_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Migrate integration tokens from Neon to Firestore with KMS encryption.

        This endpoint accepts a list of organization IDs and migrates their Slack and Notion tokens.
        It fetches tokens from the Neon database and stores them in Firestore,
        encrypting the tokens using KMS.

        NOTE: Not a public endpoint - used for internal database migration

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/migrate",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_notion_oauth_integrations_notion_oauth_post(
        self,
        *,
        access_token: str,
        metadata: typing.Dict[str, typing.Optional[typing.Any]],
        integrated_service_id: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        redirect_uri: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Handle Notion OAuth token upsert

        Args:
            request: The FastAPI request object
            body: The request body containing the access token and metadata

        Returns:
            Response indicating success

        Raises:
            HTTPException: If there's an error during the process

        Parameters
        ----------
        access_token : str

        metadata : typing.Dict[str, typing.Optional[typing.Any]]

        integrated_service_id : typing.Optional[str]

        code : typing.Optional[str]

        redirect_uri : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "integrations/notion/oauth",
            method="POST",
            json={
                "access_token": access_token,
                "integrated_service_id": integrated_service_id,
                "metadata": metadata,
                "code": code,
                "redirect_uri": redirect_uri,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def exchange_mcp_auth_mcp_authorization_post(
        self,
        *,
        code: str,
        state: str,
        url: str,
        name: str,
        integration_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        code : str

        state : str

        url : str

        name : str

        integration_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "mcp/authorization",
            method="POST",
            json={
                "code": code,
                "state": state,
                "url": url,
                "name": name,
                "integration_id": integration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def connect_mcp_mcp_connect_post(
        self,
        *,
        url: str,
        name: str,
        integration_id: str,
        headers: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        url : str

        name : str

        integration_id : str

        headers : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "mcp/connect",
            method="POST",
            json={
                "url": url,
                "name": name,
                "headers": headers,
                "integration_id": integration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_mcp_connection_mcp_servers_connection_id_delete(
        self, connection_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        connection_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"mcp/servers/{jsonable_encoder(connection_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_mcp_servers_mcp_servers_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "mcp/servers",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_info_inbox_info_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "inbox/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_get_sessions_inbox_sessions_get(
        self, *, search: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        search : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "inbox/sessions",
            method="GET",
            params={
                "search": search,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_get_notifications_inbox_notifications_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "inbox/notifications",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_get_session_by_id_inbox_session_id_get(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_delete_session_inbox_session_id_delete(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteResponse]:
        """
        Delete an inbox session and all its associated messages.

        Args:
            request: The FastAPI request
            session_id: The ID of the session to delete

        Returns:
            DeleteResponse with deletion status

        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteResponse,
                    construct_type(
                        type_=DeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_transcribe_inbox_session_id_transcribe_post(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/transcribe",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_private_files_inbox_session_id_files_post(
        self, session_id: str, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[FilesResponse]]:
        """
        Parameters
        ----------
        session_id : str

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[FilesResponse]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/files",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[FilesResponse],
                    construct_type(
                        type_=typing.List[FilesResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_get_session_messages_inbox_session_id_messages_get(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/messages",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_message_inbox_session_id_messages_post(
        self,
        session_id: str,
        *,
        messages: typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage],
        participants: typing.Sequence[SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem],
        history: typing.Optional[typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage]] = OMIT,
        files: typing.Optional[typing.Sequence[FilesAttribute]] = OMIT,
        mentions: typing.Optional[typing.Sequence[Mention]] = OMIT,
        ephemeral_agent_revision: typing.Optional[AgentRevision] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        session_id : str

        messages : typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage]

        participants : typing.Sequence[SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem]

        history : typing.Optional[typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage]]

        files : typing.Optional[typing.Sequence[FilesAttribute]]

        mentions : typing.Optional[typing.Sequence[Mention]]

        ephemeral_agent_revision : typing.Optional[AgentRevision]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/messages",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages,
                    annotation=typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage],
                    direction="write",
                ),
                "participants": convert_and_respect_annotation_metadata(
                    object_=participants,
                    annotation=typing.Sequence[SrcAppHttpRoutesInboxHandleMessageInteractionRequestParticipantsItem],
                    direction="write",
                ),
                "history": convert_and_respect_annotation_metadata(
                    object_=history,
                    annotation=typing.Sequence[SrcAppHttpRoutesInboxHandleMessageIncomingMessage],
                    direction="write",
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Sequence[FilesAttribute], direction="write"
                ),
                "mentions": convert_and_respect_annotation_metadata(
                    object_=mentions, annotation=typing.Sequence[Mention], direction="write"
                ),
                "ephemeral_agent_revision": convert_and_respect_annotation_metadata(
                    object_=ephemeral_agent_revision, annotation=AgentRevision, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_post_session_participant_inbox_sessions_session_id_participants_post(
        self,
        session_id: str,
        *,
        request: typing.Sequence[Participant],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Process an interaction request through the environment.

        Args:
            request: The FastAPI request
            session_id: The ID of the session
            interaction_request: The interaction request data

        Returns:
            Span with the results of the interaction attached to its attributes

        Parameters
        ----------
        session_id : str

        request : typing.Sequence[Participant]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/sessions/{jsonable_encoder(session_id)}/participants",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[Participant], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_cancel_session_inbox_session_id_cancel_post(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CancelResponse]:
        """
        Cancel ongoing agent response for a session.

        Args:
            request: The FastAPI request
            session_id: The ID of the session to cancel

        Returns:
            CancelResponse with cancellation status

        Parameters
        ----------
        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CancelResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CancelResponse,
                    construct_type(
                        type_=CancelResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def handle_rename_session_inbox_session_id_rename_post(
        self, session_id: str, *, title: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RenameResponse]:
        """
        Rename an inbox session by updating its title.

        Args:
            request: The FastAPI request
            session_id: The ID of the session to rename
            rename_request: The request containing the new title

        Returns:
            RenameResponse with rename status and new title

        Parameters
        ----------
        session_id : str

        title : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RenameResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"inbox/{jsonable_encoder(session_id)}/rename",
            method="POST",
            json={
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RenameResponse,
                    construct_type(
                        type_=RenameResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def execute_hook_webhooks_hook_id_get(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Execute a hook trigger.

        This is the main endpoint that external services call to trigger hooks.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def execute_hook_webhooks_hook_id_post(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Execute a hook trigger.

        This is the main endpoint that external services call to trigger hooks.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_hook_webhooks_hook_id_delete(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteHookResponse]:
        """
        Soft delete a hook.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteHookResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteHookResponse,
                    construct_type(
                        type_=DeleteHookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_hook_webhooks_hook_id_patch(
        self,
        hook_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        status: typing.Optional[str] = OMIT,
        target_config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        response_mode: typing.Optional[str] = OMIT,
        allowed_methods: typing.Optional[typing.Sequence[str]] = OMIT,
        max_payload_size: typing.Optional[int] = OMIT,
        secret: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Update a hook's configuration.

        Parameters
        ----------
        hook_id : str

        name : typing.Optional[str]

        description : typing.Optional[str]

        status : typing.Optional[str]

        target_config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        response_mode : typing.Optional[str]

        allowed_methods : typing.Optional[typing.Sequence[str]]

        max_payload_size : typing.Optional[int]

        secret : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "status": status,
                "target_config": target_config,
                "response_mode": response_mode,
                "allowed_methods": allowed_methods,
                "max_payload_size": max_payload_size,
                "secret": secret,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_hooks_webhooks_get(
        self,
        *,
        target_type: typing.Optional[str] = None,
        target_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[HooksListResponse]:
        """
        List all hooks for the current organization.

        Parameters
        ----------
        target_type : typing.Optional[str]

        target_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[HooksListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks",
            method="GET",
            params={
                "target_type": target_type,
                "target_id": target_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    HooksListResponse,
                    construct_type(
                        type_=HooksListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_hook_webhooks_post(
        self, *, request: CreateHookWebhooksPostRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateHookWebhooksPostResponse]:
        """
        Create a new hook for a workflow or other target.

        Parameters
        ----------
        request : CreateHookWebhooksPostRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateHookWebhooksPostResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=CreateHookWebhooksPostRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateHookWebhooksPostResponse,
                    construct_type(
                        type_=CreateHookWebhooksPostResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_hook_webhooks_hook_id_details_get(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetHookWebhooksHookIdDetailsGetResponse]:
        """
        Get a hook by its ID.

        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetHookWebhooksHookIdDetailsGetResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(hook_id)}/details",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetHookWebhooksHookIdDetailsGetResponse,
                    construct_type(
                        type_=GetHookWebhooksHookIdDetailsGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_info_money_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingGetInfoGetInfoResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingGetInfoGetInfoResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "money",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetInfoGetInfoResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetInfoGetInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_billing_accounts_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingGetBillingResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingGetBillingResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "accounts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetBillingResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetBillingResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_usage_accounts_usage_get(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Result]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]

        end_date : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Result]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "accounts/usage",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Result,
                    construct_type(
                        type_=Result,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_invoices_accounts_invoices_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingGetInvoicesResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingGetInvoicesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "accounts/invoices",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetInvoicesResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetInvoicesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_portal_session_accounts_portal_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingCreatePortalSessionResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingCreatePortalSessionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "accounts/portal",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingCreatePortalSessionResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingCreatePortalSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_workflow_usage_accounts_usage_workflows_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "accounts/usage/workflows",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_notifications_notifications_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingGetNotificationsResponse]:
        """
        This endpoint will pull any org facing notifications for the app to display
        Mostly billing related so far

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingGetNotificationsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "notifications",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingGetNotificationsResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingGetNotificationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def change_billing_plan_accounts_plan_put(
        self, *, name: PlanTypes, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingChangeBillingPlanResponse]:
        """
        Parameters
        ----------
        name : PlanTypes

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingChangeBillingPlanResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "accounts/plan",
            method="PUT",
            json={
                "name": name,
                "interval_type": "monthly",
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingChangeBillingPlanResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingChangeBillingPlanResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def stripe_webhook_hooks_stripe_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "hooks/stripe",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def renew_plans_crons_renew_plans_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingRenewPlansResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingRenewPlansResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "crons/renew_plans",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingRenewPlansResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingRenewPlansResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def daily_billing_tasks_crons_free_plan_usage_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingFreePlanUsageResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingFreePlanUsageResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "crons/free_plan_usage",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingFreePlanUsageResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingFreePlanUsageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def billing_hourly_crons_billing_hourly_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesBillingBillingHourlyResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesBillingBillingHourlyResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "crons/billing_hourly",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesBillingBillingHourlyResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesBillingBillingHourlyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_spans_traces_trace_id_spans_get(
        self, trace_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        trace_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"traces/{jsonable_encoder(trace_id)}/spans",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_agent_sessions_observability_agents_agent_id_sessions_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        List agent sessions for a given agent and date range.

        Args:
            request: The FastAPI request
            agent_id: The ID of the agent
            start_date: Optional start date for filtering
            end_date: Optional end date for filtering

        Returns:
            Response with list of agent sessions

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[dt.datetime]

        end_date : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/sessions",
            method="GET",
            params={
                "start_date": serialize_datetime(start_date) if start_date is not None else None,
                "end_date": serialize_datetime(end_date) if end_date is not None else None,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_agent_sessions_summary_observability_agents_agent_id_sessions_summary_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        tool_filter: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[str]
            Start date in ISO format

        end_date : typing.Optional[str]
            End date in ISO format

        limit : typing.Optional[int]
            Number of sessions per page

        cursor : typing.Optional[str]
            Pagination cursor

        tool_filter : typing.Optional[str]
            Filter sessions by tool name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/sessions/summary",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
                "limit": limit,
                "cursor": cursor,
                "tool_filter": tool_filter,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_session_details_observability_agents_agent_id_sessions_session_id_details_get(
        self, agent_id: str, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get full session details including all traces and spans for a specific session.

        This endpoint is used when a user expands a session in the UI.

        Parameters
        ----------
        agent_id : str

        session_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/sessions/{jsonable_encoder(session_id)}/details",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_agent_session_analytics_observability_agents_agent_id_analytics_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get session analytics data for a specific agent from spans table (hypertable).

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[dt.datetime]

        end_date : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/analytics",
            method="GET",
            params={
                "start_date": serialize_datetime(start_date) if start_date is not None else None,
                "end_date": serialize_datetime(end_date) if end_date is not None else None,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_agent_tool_usage_observability_agents_agent_id_tool_usage_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get tool usage statistics for a specific agent.

        This endpoint aggregates tool invocations from spans data to show
        which tools are most frequently used by an agent.

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[str]
            Start date in ISO format

        end_date : typing.Optional[str]
            End date in ISO format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/tool-usage",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_agent_distinct_tools_observability_agents_agent_id_tools_get(
        self,
        agent_id: str,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get distinct tools used by an agent.

        This endpoint returns a clean list of all tools the agent has used
        in the specified date range, with usage counts.

        Parameters
        ----------
        agent_id : str

        start_date : typing.Optional[str]
            Start date in ISO format

        end_date : typing.Optional[str]
            End date in ISO format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"observability/agents/{jsonable_encoder(agent_id)}/tools",
            method="GET",
            params={
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_pulse_feed_pulse_feed_get(
        self,
        *,
        user_id: typing.Optional[str] = None,
        agent_ids: typing.Optional[str] = None,
        action_types: typing.Optional[str] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        include_children: typing.Optional[bool] = None,
        min_significance: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PulseFeedResponse]:
        """
        Get pulse feed with enhanced filtering.

        Returns both new pulse events and legacy agent interactions.

        Parameters
        ----------
        user_id : typing.Optional[str]

        agent_ids : typing.Optional[str]

        action_types : typing.Optional[str]

        start_date : typing.Optional[str]

        end_date : typing.Optional[str]

        limit : typing.Optional[int]

        include_children : typing.Optional[bool]

        min_significance : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PulseFeedResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/feed",
            method="GET",
            params={
                "user_id": user_id,
                "agent_ids": agent_ids,
                "action_types": action_types,
                "start_date": start_date,
                "end_date": end_date,
                "limit": limit,
                "include_children": include_children,
                "min_significance": min_significance,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PulseFeedResponse,
                    construct_type(
                        type_=PulseFeedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_pulse_json_pulse_post(
        self,
        *,
        description: str,
        agents: typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]],
        action: typing.Optional[str] = OMIT,
        objects: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        context: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        visibility: typing.Optional[str] = OMIT,
        duration_minutes: typing.Optional[float] = OMIT,
        content: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        text: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreatePulseResponse]:
        """
        Create pulse from JSON data (existing endpoint)

        Parameters
        ----------
        description : str

        agents : typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]

        action : typing.Optional[str]

        objects : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]

        context : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        tags : typing.Optional[typing.Sequence[str]]

        visibility : typing.Optional[str]

        duration_minutes : typing.Optional[float]

        content : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        text : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreatePulseResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse",
            method="POST",
            json={
                "action": action,
                "description": description,
                "agents": agents,
                "objects": objects,
                "context": context,
                "tags": tags,
                "visibility": visibility,
                "duration_minutes": duration_minutes,
                "content": content,
                "text": text,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreatePulseResponse,
                    construct_type(
                        type_=CreatePulseResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_entity_activities_pulse_activities_get(
        self,
        *,
        entity_id: typing.Optional[str] = None,
        entity_type: typing.Optional[str] = None,
        involving_agent: typing.Optional[str] = None,
        on_object: typing.Optional[str] = None,
        of_type: typing.Optional[str] = None,
        with_outcome: typing.Optional[str] = None,
        since_days: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get activities - either for a specific entity or with general filters

        Parameters
        ----------
        entity_id : typing.Optional[str]
            ID of the entity

        entity_type : typing.Optional[str]
            Type of entity (account, deal, user, etc)

        involving_agent : typing.Optional[str]

        on_object : typing.Optional[str]

        of_type : typing.Optional[str]

        with_outcome : typing.Optional[str]

        since_days : typing.Optional[int]

        limit : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/activities",
            method="GET",
            params={
                "entity_id": entity_id,
                "entity_type": entity_type,
                "involving_agent": involving_agent,
                "on_object": on_object,
                "of_type": of_type,
                "with_outcome": with_outcome,
                "since_days": since_days,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_create_pulse_store_create_post(
        self,
        *,
        type: str,
        data: typing.Dict[str, typing.Optional[typing.Any]],
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Create a new entity.

        Example:
            POST /pulse/store/create
            {
                "type": "todo",
                "data": {
                    "title": "Buy milk",
                    "completed": false
                }
            }

        Parameters
        ----------
        type : str
            Entity type (e.g., 'todo', 'note', 'task')

        data : typing.Dict[str, typing.Optional[typing.Any]]
            Entity data

        tags : typing.Optional[typing.Sequence[str]]
            Optional tags

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/create",
            method="POST",
            json={
                "type": type,
                "data": data,
                "tags": tags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_update_pulse_store_update_post(
        self,
        *,
        id: str,
        updates: typing.Dict[str, typing.Optional[typing.Any]],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Update an entity (partial updates).

        Example:
            POST /pulse/store/update
            {
                "id": "todo_abc123",
                "updates": {
                    "completed": true,
                    "completed_at": "2024-01-01T12:00:00Z"
                }
            }

        Parameters
        ----------
        id : str
            Entity ID

        updates : typing.Dict[str, typing.Optional[typing.Any]]
            Partial updates to apply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/update",
            method="POST",
            json={
                "id": id,
                "updates": updates,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_get_tags_pulse_store_tags_get(
        self,
        *,
        type: typing.Optional[str] = None,
        prefix: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TagsResponse]:
        """
        Get all unique tags across entities.

        Example:
            GET /pulse/store/tags?type=file&prefix=folder:

        Parameters
        ----------
        type : typing.Optional[str]

        prefix : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TagsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/tags",
            method="GET",
            params={
                "type": type,
                "prefix": prefix,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagsResponse,
                    construct_type(
                        type_=TagsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_update_tags_pulse_store_tags_update_post(
        self,
        *,
        id: str,
        add_tags: typing.Optional[typing.Sequence[str]] = OMIT,
        remove_tags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Add or remove tags from an entity.

        Example:
            POST /pulse/store/tags/update
            {
                "id": "file-uuid",
                "add_tags": ["folder:marketing", "folder:campaigns"],
                "remove_tags": ["folder:archive"]
            }

        Parameters
        ----------
        id : str
            Entity ID

        add_tags : typing.Optional[typing.Sequence[str]]
            Tags to add

        remove_tags : typing.Optional[typing.Sequence[str]]
            Tags to remove

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/tags/update",
            method="POST",
            json={
                "id": id,
                "add_tags": add_tags,
                "remove_tags": remove_tags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_get_pulse_store_entity_id_get(
        self, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Get a single entity.

        GET /pulse/store/{entity_id}

        Parameters
        ----------
        entity_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/store/{jsonable_encoder(entity_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_delete_pulse_store_entity_id_delete(
        self,
        entity_id: str,
        *,
        soft: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Delete an entity.

        DELETE /pulse/store/{entity_id}?soft=true

        Parameters
        ----------
        entity_id : str

        soft : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/store/{jsonable_encoder(entity_id)}",
            method="DELETE",
            params={
                "soft": soft,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_query_pulse_store_query_post(
        self,
        *,
        type: typing.Optional[str] = OMIT,
        filter: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        limit: typing.Optional[int] = OMIT,
        include_deleted: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Query entities with filters.

        Example:
            POST /pulse/store/query
            {
                "type": "file",
                "tags": ["folder:marketing"],
                "filter": {
                    "completed": false
                },
                "limit": 50
            }

        Parameters
        ----------
        type : typing.Optional[str]
            Filter by entity type

        filter : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Filter by data fields

        tags : typing.Optional[typing.Sequence[str]]
            Filter by tags (must have ALL specified tags)

        limit : typing.Optional[int]
            Max results

        include_deleted : typing.Optional[bool]
            Include soft-deleted entities

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/query",
            method="POST",
            json={
                "type": type,
                "filter": filter,
                "tags": tags,
                "limit": limit,
                "include_deleted": include_deleted,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_query_fluent_pulse_store_query_fluent_post(
        self,
        *,
        select: str,
        where: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        with_: typing.Optional[typing.Sequence[FluentQueryRequestWithItem]] = OMIT,
        order_by: typing.Optional[typing.Sequence[typing.Dict[str, str]]] = OMIT,
        limit: typing.Optional[int] = OMIT,
        offset: typing.Optional[int] = OMIT,
        cursor: typing.Optional[str] = OMIT,
        count: typing.Optional[bool] = OMIT,
        group_by: typing.Optional[str] = OMIT,
        aggregations: typing.Optional[typing.Dict[str, typing.Dict[str, str]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]:
        """
        Powerful fluent query API with relationships and advanced filtering.

        Example:
            POST /pulse/store/query/fluent
            {
                "select": "deal",
                "where": [
                    {"field": "stage", "operator": "in", "value": ["negotiation", "proposal"]},
                    {"field": "value", "operator": ">=", "value": 50000}
                ],
                "with": ["account", "contact"],
                "orderBy": [{"field": "value", "direction": "desc"}],
                "limit": 50
            }

        Returns:
            {
                "ok": true,
                "data": [entity, ...],
                "total": 123,
                "includes": {
                    "account": {entity_id: account_entity},
                    "contact": {entity_id: contact_entity}
                }
            }

        Parameters
        ----------
        select : str
            Entity type to select

        where : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            WHERE conditions: [{field, operator, value}, ...]

        with_ : typing.Optional[typing.Sequence[FluentQueryRequestWithItem]]
            Relations to include (auto-JOIN)

        order_by : typing.Optional[typing.Sequence[typing.Dict[str, str]]]
            Order by: [{field, direction}, ...]

        limit : typing.Optional[int]
            Max results

        offset : typing.Optional[int]
            Offset for pagination

        cursor : typing.Optional[str]
            Cursor for pagination

        count : typing.Optional[bool]
            Include total count

        group_by : typing.Optional[str]
            Group by field

        aggregations : typing.Optional[typing.Dict[str, typing.Dict[str, str]]]
            Aggregations: {alias: {function, field}}

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Optional[typing.Any]]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/query/fluent",
            method="POST",
            json={
                "select": select,
                "where": where,
                "with": convert_and_respect_annotation_metadata(
                    object_=with_, annotation=typing.Sequence[FluentQueryRequestWithItem], direction="write"
                ),
                "orderBy": order_by,
                "limit": limit,
                "offset": offset,
                "cursor": cursor,
                "count": count,
                "groupBy": group_by,
                "aggregations": aggregations,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    construct_type(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def store_batch_create_pulse_store_batch_create_post(
        self, *, entities: typing.Sequence[CreateEntityRequest], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StoreResponse]:
        """
        Create multiple entities.

        Example:
            POST /pulse/store/batch/create
            {
                "entities": [
                    {"type": "todo", "data": {"title": "Task 1"}},
                    {"type": "todo", "data": {"title": "Task 2"}}
                ]
            }

        Parameters
        ----------
        entities : typing.Sequence[CreateEntityRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StoreResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/store/batch/create",
            method="POST",
            json={
                "entities": convert_and_respect_annotation_metadata(
                    object_=entities, annotation=typing.Sequence[CreateEntityRequest], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StoreResponse,
                    construct_type(
                        type_=StoreResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_entities_pulse_entities_get(
        self,
        *,
        limit: typing.Optional[int] = None,
        entity_type: typing.Optional[str] = None,
        current_state: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        List all entities extracted from activities.

        Returns entities with their mention counts and metadata.
        Used by the frontend ChannelEntitiesPanel.

        Parameters
        ----------
        limit : typing.Optional[int]

        entity_type : typing.Optional[str]
            Filter by entity type

        current_state : typing.Optional[bool]
            Return only current state via quantum collapse

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/entities",
            method="GET",
            params={
                "limit": limit,
                "entity_type": entity_type,
                "current_state": current_state,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_entities_pulse_entities_query_post(
        self,
        *,
        entity_type: typing.Optional[str] = OMIT,
        activity_filters: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        outcomes: typing.Optional[typing.Sequence[str]] = OMIT,
        actions: typing.Optional[typing.Sequence[str]] = OMIT,
        time: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        kinds: typing.Optional[typing.Sequence[str]] = OMIT,
        roles: typing.Optional[typing.Sequence[str]] = OMIT,
        current_state: typing.Optional[bool] = OMIT,
        include_stats: typing.Optional[bool] = OMIT,
        group_by: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        min_activities: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Query entities (agents or objects) across activities

        Examples:

        # Find all sales agents
        {
            "entity_type": "agent",
            "tags": ["sales"],
            "include_stats": true
        }

        # Find documents involved in approved deals
        {
            "entity_type": "object",
            "kinds": ["document", "contract"],
            "outcomes": ["approved"],
            "include_stats": true
        }

        # Find active users in last 7 days
        {
            "entity_type": "agent",
            "kinds": ["user"],
            "time": {"last": "7d"},
            "min_activities": 5,
            "include_stats": true
        }

        # Find cross-functional agents (sales + engineering)
        {
            "entity_type": "agent",
            "tags": ["sales", "engineering"],
            "group_by": "kind"
        }

        Parameters
        ----------
        entity_type : typing.Optional[str]
            'agent' or 'object'

        activity_filters : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Filter activities that entities appear in

        tags : typing.Optional[typing.Sequence[str]]
            Activities must have these tags

        outcomes : typing.Optional[typing.Sequence[str]]
            Activities must have these outcomes

        actions : typing.Optional[typing.Sequence[str]]
            Activities must have these actions

        time : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Time range for activities

        kinds : typing.Optional[typing.Sequence[str]]
            Entity kinds to include (user, team, document, etc)

        roles : typing.Optional[typing.Sequence[str]]
            Entity roles to include

        current_state : typing.Optional[bool]
            Return only current state via quantum collapse

        include_stats : typing.Optional[bool]
            Include activity statistics for each entity

        group_by : typing.Optional[str]
            Group entities by field (kind, role)

        limit : typing.Optional[int]

        min_activities : typing.Optional[int]
            Minimum activities for entity to be included

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/entities/query",
            method="POST",
            json={
                "entity_type": entity_type,
                "activity_filters": activity_filters,
                "tags": tags,
                "outcomes": outcomes,
                "actions": actions,
                "time": time,
                "kinds": kinds,
                "roles": roles,
                "current_state": current_state,
                "include_stats": include_stats,
                "group_by": group_by,
                "limit": limit,
                "min_activities": min_activities,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_entity_network_pulse_entities_entity_id_network_get(
        self,
        entity_id: str,
        *,
        depth: typing.Optional[int] = None,
        min_interactions: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get the collaboration network around an entity

        Returns entities connected to the target entity through shared activities

        Parameters
        ----------
        entity_id : str

        depth : typing.Optional[int]
            Network depth

        min_interactions : typing.Optional[int]
            Minimum interactions to include connection

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/entities/{jsonable_encoder(entity_id)}/network",
            method="GET",
            params={
                "depth": depth,
                "min_interactions": min_interactions,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_entity_network_pg_pulse_entities_entity_id_network_pg_get(
        self,
        entity_id: str,
        *,
        depth: typing.Optional[int] = None,
        min_interactions: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get the collaboration network around an entity using PostgreSQL.

        Returns entities connected to the target entity through shared activities.
        This is optimized for PostgreSQL and uses efficient SQL queries instead of
        multiple API calls.

        Parameters
        ----------
        entity_id : str

        depth : typing.Optional[int]
            Network depth

        min_interactions : typing.Optional[int]
            Minimum interactions to include connection

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/entities/{jsonable_encoder(entity_id)}/network/pg",
            method="GET",
            params={
                "depth": depth,
                "min_interactions": min_interactions,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_entity_details_pulse_entities_entity_type_entity_id_get(
        self,
        entity_type: str,
        entity_id: str,
        *,
        include_activities: typing.Optional[bool] = None,
        time_range: typing.Optional[str] = None,
        current_state: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get detailed information about a specific entity

        When current_state=true, uses quantum collapse to return only the latest state.
        Otherwise includes all activities they've been involved in and collaboration patterns.

        Parameters
        ----------
        entity_type : str

        entity_id : str

        include_activities : typing.Optional[bool]

        time_range : typing.Optional[str]
            Time range like '7d', '30d'

        current_state : typing.Optional[bool]
            Return only current state via quantum collapse

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/entities/{jsonable_encoder(entity_type)}/{jsonable_encoder(entity_id)}",
            method="GET",
            params={
                "include_activities": include_activities,
                "time_range": time_range,
                "current_state": current_state,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_schemas_pulse_schemas_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SchemasResponse]:
        """
        Get all schemas for dynamic form generation.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SchemasResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/schemas",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SchemasResponse,
                    construct_type(
                        type_=SchemasResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_activities_pulse_search_post(
        self,
        *,
        query: typing.Optional[str] = OMIT,
        search_type: typing.Optional[SearchRequestSearchType] = OMIT,
        filters: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        limit: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Hybrid search for activities using PostgreSQL full-text and vector search.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        query : typing.Optional[str]
            Search query text

        search_type : typing.Optional[SearchRequestSearchType]
            Type of search

        filters : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Additional filters to apply

        limit : typing.Optional[int]
            Maximum results to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/search",
            method="POST",
            json={
                "query": query,
                "search_type": search_type,
                "filters": filters,
                "limit": limit,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_entities_pulse_search_entities_post(
        self,
        *,
        query: str,
        entity_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        entity_types: typing.Optional[typing.Sequence[str]] = OMIT,
        mode: typing.Optional[EntitySearchRequestMode] = OMIT,
        return_format: typing.Optional[EntitySearchRequestReturnFormat] = OMIT,
        limit: typing.Optional[int] = OMIT,
        similarity_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Search for entities with document content using hybrid search.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        query : str
            Search query text

        entity_ids : typing.Optional[typing.Sequence[str]]
            Specific entity IDs to search within

        entity_types : typing.Optional[typing.Sequence[str]]
            Entity types to search (file, note, etc)

        mode : typing.Optional[EntitySearchRequestMode]
            Search mode

        return_format : typing.Optional[EntitySearchRequestReturnFormat]
            What to return - chunks, entity info, or full text

        limit : typing.Optional[int]
            Max results

        similarity_threshold : typing.Optional[float]
            Minimum similarity score

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/search/entities",
            method="POST",
            json={
                "query": query,
                "entity_ids": entity_ids,
                "entity_types": entity_types,
                "mode": mode,
                "return_format": return_format,
                "limit": limit,
                "similarity_threshold": similarity_threshold,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_search_indexes_pulse_search_update_indexes_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Update search indexes for existing activities.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/search/update-indexes",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_distinct_values_pulse_search_distinct_field_get(
        self, field: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get distinct values for a specific field to help with query building.

        Thin handler - delegates to PulseSearch domain API.

        Parameters
        ----------
        field : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/search/distinct/{jsonable_encoder(field)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_builder_pulse_query_post(
        self,
        *,
        limit: typing.Optional[int] = OMIT,
        offset: typing.Optional[int] = OMIT,
        text_query: typing.Optional[str] = OMIT,
        time_range_start: typing.Optional[dt.datetime] = OMIT,
        time_range_end: typing.Optional[dt.datetime] = OMIT,
        last_hours: typing.Optional[int] = OMIT,
        last_days: typing.Optional[int] = OMIT,
        agent_types: typing.Optional[typing.Sequence[str]] = OMIT,
        agent_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        object_types: typing.Optional[typing.Sequence[str]] = OMIT,
        object_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        action_types: typing.Optional[typing.Sequence[str]] = OMIT,
        action_statuses: typing.Optional[typing.Sequence[str]] = OMIT,
        specific_actions: typing.Optional[typing.Sequence[str]] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        exclude_tags: typing.Optional[typing.Sequence[str]] = OMIT,
        tag_mode: typing.Optional[QueryBuilderRequestTagMode] = OMIT,
        min_duration_minutes: typing.Optional[float] = OMIT,
        max_duration_minutes: typing.Optional[float] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        team_name: typing.Optional[str] = OMIT,
        deal_stages: typing.Optional[typing.Sequence[str]] = OMIT,
        revenue_impact: typing.Optional[bool] = OMIT,
        churn_risk: typing.Optional[bool] = OMIT,
        escalation_level: typing.Optional[str] = OMIT,
        trace_id: typing.Optional[str] = OMIT,
        triggered_by: typing.Optional[str] = OMIT,
        sort_by: typing.Optional[QueryBuilderRequestSortBy] = OMIT,
        sort_direction: typing.Optional[QueryBuilderRequestSortDirection] = OMIT,
        count_only: typing.Optional[bool] = OMIT,
        explain: typing.Optional[bool] = OMIT,
        aggregate: typing.Optional[bool] = OMIT,
        group_by: typing.Optional[typing.Sequence[QueryBuilderRequestGroupByItem]] = OMIT,
        group_by_tag_prefix: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Execute a declarative query using the powerful PulseQuery builder

        This endpoint provides a more structured and powerful alternative to text-based search,
        allowing complex filtering, aggregation, and business logic queries.

        Examples:

        # Find all activities by specific agents in last 7 days
        {
            "agent_types": ["user"],
            "last_days": 7,
            "sort_by": "time"
        }

        # Customer journey analysis
        {
            "customer_id": "customer_123",
            "last_days": 30,
            "sort_by": "time",
            "sort_direction": "asc"
        }

        # Revenue impact events with duration filters
        {
            "revenue_impact": true,
            "min_duration_minutes": 5,
            "tags": ["sales", "deal"],
            "tag_mode": "all"
        }

        # Aggregated metrics by team
        {
            "last_days": 14,
            "aggregate": true,
            "group_by": ["agent_type"],
            "team_name": "engineering"
        }

        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum results to return

        offset : typing.Optional[int]
            Offset for pagination

        text_query : typing.Optional[str]
            Text to search in descriptions

        time_range_start : typing.Optional[dt.datetime]
            Start time for filtering

        time_range_end : typing.Optional[dt.datetime]
            End time for filtering

        last_hours : typing.Optional[int]
            Filter to last N hours

        last_days : typing.Optional[int]
            Filter to last N days

        agent_types : typing.Optional[typing.Sequence[str]]
            Filter by agent types

        agent_ids : typing.Optional[typing.Sequence[str]]
            Filter by specific agent IDs

        object_types : typing.Optional[typing.Sequence[str]]
            Filter by object types

        object_ids : typing.Optional[typing.Sequence[str]]
            Filter by specific object IDs

        action_types : typing.Optional[typing.Sequence[str]]
            Filter by action types

        action_statuses : typing.Optional[typing.Sequence[str]]
            Filter by action statuses

        specific_actions : typing.Optional[typing.Sequence[str]]
            Filter by specific action names

        tags : typing.Optional[typing.Sequence[str]]
            Tags to include

        exclude_tags : typing.Optional[typing.Sequence[str]]
            Tags to exclude

        tag_mode : typing.Optional[QueryBuilderRequestTagMode]
            Whether to match any or all tags

        min_duration_minutes : typing.Optional[float]
            Minimum duration in minutes

        max_duration_minutes : typing.Optional[float]
            Maximum duration in minutes

        customer_id : typing.Optional[str]
            Filter by customer ID

        team_name : typing.Optional[str]
            Filter by team

        deal_stages : typing.Optional[typing.Sequence[str]]
            Filter by deal stages

        revenue_impact : typing.Optional[bool]
            Filter for revenue impact events

        churn_risk : typing.Optional[bool]
            Filter for churn risk events

        escalation_level : typing.Optional[str]
            Filter by escalation level

        trace_id : typing.Optional[str]
            Filter by trace ID

        triggered_by : typing.Optional[str]
            Filter by triggering event

        sort_by : typing.Optional[QueryBuilderRequestSortBy]
            Sort field

        sort_direction : typing.Optional[QueryBuilderRequestSortDirection]
            Sort direction

        count_only : typing.Optional[bool]
            Return only count, not full results

        explain : typing.Optional[bool]
            Include query explanation

        aggregate : typing.Optional[bool]
            Return aggregated results

        group_by : typing.Optional[typing.Sequence[QueryBuilderRequestGroupByItem]]
            Group by fields for aggregation

        group_by_tag_prefix : typing.Optional[str]
            Group by tag prefix (e.g., 'customer:')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/query",
            method="POST",
            json={
                "limit": limit,
                "offset": offset,
                "text_query": text_query,
                "time_range_start": time_range_start,
                "time_range_end": time_range_end,
                "last_hours": last_hours,
                "last_days": last_days,
                "agent_types": agent_types,
                "agent_ids": agent_ids,
                "object_types": object_types,
                "object_ids": object_ids,
                "action_types": action_types,
                "action_statuses": action_statuses,
                "specific_actions": specific_actions,
                "tags": tags,
                "exclude_tags": exclude_tags,
                "tag_mode": tag_mode,
                "min_duration_minutes": min_duration_minutes,
                "max_duration_minutes": max_duration_minutes,
                "customer_id": customer_id,
                "team_name": team_name,
                "deal_stages": deal_stages,
                "revenue_impact": revenue_impact,
                "churn_risk": churn_risk,
                "escalation_level": escalation_level,
                "trace_id": trace_id,
                "triggered_by": triggered_by,
                "sort_by": sort_by,
                "sort_direction": sort_direction,
                "count_only": count_only,
                "explain": explain,
                "aggregate": aggregate,
                "group_by": group_by,
                "group_by_tag_prefix": group_by_tag_prefix,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_builder_schema_pulse_query_schema_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get the schema for the query builder, showing all available filters and options

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/query/schema",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_pulse_files_stream_pulse_files_stream_post(
        self, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Upload files to Pulse with activity tracking and optional RAG processing.
        Returns a streaming response with progress updates.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/files/stream",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_pulse_files_pulse_files_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get list of files for an organization.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/files",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def download_pulse_file_pulse_files_file_name_get(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get a signed URL for downloading a file.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/files/{jsonable_encoder(file_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_pulse_file_pulse_files_file_name_delete(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Delete a file and its associated chunks.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/files/{jsonable_encoder(file_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_file_chunks_pulse_files_file_name_chunks_get(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get RAG document chunks for a file.

        Thin handler - delegates to PulseFiles domain API.

        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/files/{jsonable_encoder(file_name)}/chunks",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_ai_suggestion_pulse_security_questionnaire_ai_suggest_post(
        self,
        *,
        question_id: str,
        question_text: str,
        category: str,
        questionnaire_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Generate AI suggestion for a security question using RAG.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        question_id : str

        question_text : str

        category : str

        questionnaire_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/security-questionnaire/ai-suggest",
            method="POST",
            json={
                "question_id": question_id,
                "question_text": question_text,
                "category": category,
                "questionnaire_id": questionnaire_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_batch_suggestions_pulse_security_questionnaire_batch_suggest_post(
        self,
        *,
        question_ids: typing.Sequence[str],
        questionnaire_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Generate AI suggestions for multiple questions in batch.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        question_ids : typing.Sequence[str]

        questionnaire_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "pulse/security-questionnaire/batch-suggest",
            method="POST",
            json={
                "question_ids": question_ids,
                "questionnaire_id": questionnaire_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_questionnaire_files_pulse_security_questionnaire_questionnaire_id_files_put(
        self,
        questionnaire_id: str,
        *,
        file_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Update the selected files for a questionnaire.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        questionnaire_id : str

        file_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/security-questionnaire/{jsonable_encoder(questionnaire_id)}/files",
            method="PUT",
            json={
                "file_ids": file_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_questionnaire_with_questions_pulse_security_questionnaire_questionnaire_id_get(
        self, questionnaire_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Get questionnaire with all its questions loaded.

        Thin handler - delegates to PulseQuestionnaire domain API.

        Parameters
        ----------
        questionnaire_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pulse/security-questionnaire/{jsonable_encoder(questionnaire_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def seed_agents_onboarding_seed_agents_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Manually seed default agent personas for a new organization.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "onboarding/seed-agents",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def find_me_me_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SrcAppHttpRoutesOnboardingHandleGetMeResponse]:
        """
        Get the current authenticated user's information.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesOnboardingHandleGetMeResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "me",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesOnboardingHandleGetMeResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesOnboardingHandleGetMeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_me_me_put(
        self,
        *,
        favorites: typing.Optional[typing.Sequence[FavoriteRef]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SrcAppHttpRoutesOnboardingHandleUpdateMeResponse]:
        """
        Update the current authenticated user's information.

        Parameters
        ----------
        favorites : typing.Optional[typing.Sequence[FavoriteRef]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SrcAppHttpRoutesOnboardingHandleUpdateMeResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "me",
            method="PUT",
            json={
                "favorites": convert_and_respect_annotation_metadata(
                    object_=favorites, annotation=typing.Sequence[FavoriteRef], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SrcAppHttpRoutesOnboardingHandleUpdateMeResponse,
                    construct_type(
                        type_=SrcAppHttpRoutesOnboardingHandleUpdateMeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def find_all_scout_hooks_hooks_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ScoutHooksResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ScoutHooksResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "hooks",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScoutHooksResponse,
                    construct_type(
                        type_=ScoutHooksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_scout_hook_hooks_post(
        self,
        *,
        hook_config: typing.Optional[ScoutHookConfigHttp] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        triggering_events: typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ScoutHookResponse]:
        """
        Parameters
        ----------
        hook_config : typing.Optional[ScoutHookConfigHttp]

        name : typing.Optional[str]

        description : typing.Optional[str]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        triggering_events : typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ScoutHookResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "hooks",
            method="POST",
            json={
                "hook_config": convert_and_respect_annotation_metadata(
                    object_=hook_config, annotation=ScoutHookConfigHttp, direction="write"
                ),
                "name": name,
                "description": description,
                "metadata": metadata,
                "triggering_events": convert_and_respect_annotation_metadata(
                    object_=triggering_events,
                    annotation=typing.Sequence[ScoutHookUpdateTriggeringEventsItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScoutHookResponse,
                    construct_type(
                        type_=ScoutHookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_scout_hook_hooks_hook_id_put(
        self,
        hook_id: str,
        *,
        hook_config: typing.Optional[ScoutHookConfigHttp] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        triggering_events: typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ScoutHookResponse]:
        """
        Parameters
        ----------
        hook_id : str

        hook_config : typing.Optional[ScoutHookConfigHttp]

        name : typing.Optional[str]

        description : typing.Optional[str]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        triggering_events : typing.Optional[typing.Sequence[ScoutHookUpdateTriggeringEventsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ScoutHookResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"hooks/{jsonable_encoder(hook_id)}",
            method="PUT",
            json={
                "hook_config": convert_and_respect_annotation_metadata(
                    object_=hook_config, annotation=ScoutHookConfigHttp, direction="write"
                ),
                "name": name,
                "description": description,
                "metadata": metadata,
                "triggering_events": convert_and_respect_annotation_metadata(
                    object_=triggering_events,
                    annotation=typing.Sequence[ScoutHookUpdateTriggeringEventsItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScoutHookResponse,
                    construct_type(
                        type_=ScoutHookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_scout_hook_hooks_hook_id_delete(
        self, hook_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        hook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"hooks/{jsonable_encoder(hook_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def rotate_api_keys_organization_rotate_keys_post(
        self,
        *,
        confirm: typing.Optional[bool] = OMIT,
        grace_period_hours: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Rotate API keys for the current organization.

        Delegates to ProfileManager for the actual business logic.

        Parameters
        ----------
        confirm : typing.Optional[bool]

        grace_period_hours : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "organization/rotate-keys",
            method="POST",
            json={
                "confirm": confirm,
                "grace_period_hours": grace_period_hours,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_tags_tags_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListTagsResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListTagsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tags",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListTagsResponse,
                    construct_type(
                        type_=ListTagsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_tag_tags_post(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateTagResponse]:
        """
        Parameters
        ----------
        name : str

        description : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateTagResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tags",
            method="POST",
            json={
                "name": name,
                "description": description,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateTagResponse,
                    construct_type(
                        type_=CreateTagResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_tag_tags_tag_id_get(
        self, tag_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Tag]:
        """
        Parameters
        ----------
        tag_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Tag]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tags/{jsonable_encoder(tag_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tag,
                    construct_type(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_tag_tags_tag_id_put(
        self,
        tag_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateTagResponse]:
        """
        Parameters
        ----------
        tag_id : str

        name : typing.Optional[str]

        description : typing.Optional[str]

        active : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateTagResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tags/{jsonable_encoder(tag_id)}",
            method="PUT",
            json={
                "name": name,
                "description": description,
                "active": active,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateTagResponse,
                    construct_type(
                        type_=UpdateTagResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_tools_tools_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListToolsResponse]:
        """
        Get available tools for the organization with full input schemas.

        This endpoint delegates to the Tool domain API which provides:
        - Tool authorization checking
        - Schema retrieval from all sources
        - Comprehensive tool information

        Args:
            request: The FastAPI request

        Returns:
            ListToolsResponse with detailed tool information

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListToolsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListToolsResponse,
                    construct_type(
                        type_=ListToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_tool_tools_tool_name_get(
        self, tool_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ToolDetails]:
        """
        Get detailed information about a specific tool.

        This endpoint returns comprehensive information about a single tool including:
        - Tool metadata (name, description, icon)
        - Input schema
        - Labels and categorization

        Args:
            request: The FastAPI request
            tool_name: The name of the tool to retrieve

        Returns:
            ToolDetails with comprehensive tool information

        Raises:
            HTTPException: 404 if tool not found, 403 if not available

        Parameters
        ----------
        tool_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolDetails]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(tool_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolDetails,
                    construct_type(
                        type_=ToolDetails,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def execute_tool_tools_tool_name_execute_post(
        self,
        tool_name: str,
        *,
        input_data: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ExecuteToolResponse]:
        """
        Execute a specific tool.

        This endpoint delegates to the Tool domain API which handles:
        - Tool authorization
        - Tool discovery from all sources
        - Context injection
        - Tool execution

        Args:
            request: The FastAPI request
            tool_name: The name of the tool to execute (from path parameter)
            body: The tool execution request body

        Returns:
            ExecuteToolResponse with execution result or error

        Parameters
        ----------
        tool_name : str

        input_data : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input data for the tool execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ExecuteToolResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(tool_name)}/execute",
            method="POST",
            json={
                "input_data": input_data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExecuteToolResponse,
                    construct_type(
                        type_=ExecuteToolResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def interact_handler_world_agent_id_session_id_interact_post(
        self,
        agent_id: str,
        session_id: str,
        *,
        messages: typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        session_id : str

        messages : typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"world/{jsonable_encoder(agent_id)}/{jsonable_encoder(session_id)}/_interact",
            method="POST",
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages,
                    annotation=typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def interact_handler_world_agent_id_interact_post(
        self,
        agent_id: str,
        *,
        messages: typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
        session_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        messages : typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage]

        session_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"world/{jsonable_encoder(agent_id)}/_interact",
            method="POST",
            params={
                "session_id": session_id,
            },
            json={
                "messages": convert_and_respect_annotation_metadata(
                    object_=messages,
                    annotation=typing.Sequence[SrcAppHttpRoutesWorldInteractIncomingMessage],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_agents_agents_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_agent_agents_post(
        self,
        *,
        agent: str,
        revision: str,
        agent_image: core.File,
        agent_id: typing.Optional[str] = OMIT,
        activate: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent : str

        revision : str

        agent_image : core.File
            See core.File for more documentation

        agent_id : typing.Optional[str]

        activate : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="POST",
            data={
                "agent": agent,
                "agent_id": agent_id,
                "activate": activate,
                "revision": revision,
            },
            files={
                "agent_image": agent_image,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_active_agent_agents_agent_id_active_get(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Retrieve an agent and its active revision by agent_id.
        Verifies that the agent belongs to the actor's organization.

        Parameters
        ----------
        agent_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/active",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_tools_agents_tools_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ToolsResponse]:
        """
        Get available tools for the organization.

        Args:
            request: The FastAPI request

        Returns:
            Span with the list of available tools attached to its attributes

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/tools",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsResponse,
                    construct_type(
                        type_=ToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_agent_agents_agent_id_delete(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def expire_blobs_expire_blobs_post(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "_expire_blobs",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_drive_drive_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "drive",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_drive_file_drive_files_file_name_get(
        self, file_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        file_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"drive/files/{jsonable_encoder(file_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_files_to_drive_drive_files_post(
        self, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "drive/files",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_drive_crawl_drive_crawls_post(
        self,
        *,
        source_sync_settings: SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings,
        url: str,
        schedule: typing.Optional[Schedule] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Since we do not have domain apis for collections we have to import
        the route functions and pass the request through.

        We could get the org key and move this logic to the drive domain api
        but we would then need to get the org secret key to make http requests
        since importing into the drive domain api would cause circular dependencies.
        Which then forces us to use network requests via scout sdk or httpx.

        This is the lesser evil I.M.O.

        Parameters
        ----------
        source_sync_settings : SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings

        url : str

        schedule : typing.Optional[Schedule]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "drive/crawls",
            method="POST",
            json={
                "source_sync_settings": convert_and_respect_annotation_metadata(
                    object_=source_sync_settings,
                    annotation=SrcAppHttpRoutesDriveCreateDriveCrawlPayloadSourceSyncSettings,
                    direction="write",
                ),
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=Schedule, direction="write"
                ),
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def grant_access_drive_grant_post(
        self,
        *,
        agent_ids: typing.Sequence[str],
        resources: typing.Sequence[Resource],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_ids : typing.Sequence[str]

        resources : typing.Sequence[Resource]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "drive/grant",
            method="POST",
            json={
                "agent_ids": agent_ids,
                "resources": convert_and_respect_annotation_metadata(
                    object_=resources, annotation=typing.Sequence[Resource], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def revoke_access_drive_revoke_post(
        self,
        *,
        agent_ids: typing.Sequence[str],
        resource_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        agent_ids : typing.Sequence[str]

        resource_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "drive/revoke",
            method="POST",
            json={
                "agent_ids": agent_ids,
                "resource_ids": resource_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    construct_type(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
