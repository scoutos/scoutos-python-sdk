# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .fluent_query_request_with_item import FluentQueryRequestWithItem


class FluentQueryRequest(UncheckedBaseModel):
    """
    Fluent query request - powerful, declarative querying.

    Example:
        {
            "select": "deal",
            "where": [
                {"field": "stage", "operator": "in", "value": ["negotiation", "proposal"]},
                {"field": "value", "operator": ">=", "value": 50000}
            ],
            "with": ["account", "contact"],
            "orderBy": [{"field": "value", "direction": "desc"}],
            "limit": 50
        }
    """

    select: str = pydantic.Field()
    """
    Entity type to select
    """

    where: typing.Optional[typing.List[typing.Dict[str, typing.Optional[typing.Any]]]] = pydantic.Field(default=None)
    """
    WHERE conditions: [{field, operator, value}, ...]
    """

    with_: typing_extensions.Annotated[
        typing.Optional[typing.List[FluentQueryRequestWithItem]], FieldMetadata(alias="with")
    ] = pydantic.Field(default=None)
    """
    Relations to include (auto-JOIN)
    """

    order_by: typing_extensions.Annotated[
        typing.Optional[typing.List[typing.Dict[str, str]]], FieldMetadata(alias="orderBy")
    ] = pydantic.Field(default=None)
    """
    Order by: [{field, direction}, ...]
    """

    limit: typing.Optional[int] = pydantic.Field(default=None)
    """
    Max results
    """

    offset: typing.Optional[int] = pydantic.Field(default=None)
    """
    Offset for pagination
    """

    cursor: typing.Optional[str] = pydantic.Field(default=None)
    """
    Cursor for pagination
    """

    count: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Include total count
    """

    group_by: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="groupBy")] = pydantic.Field(
        default=None
    )
    """
    Group by field
    """

    aggregations: typing.Optional[typing.Dict[str, typing.Dict[str, str]]] = pydantic.Field(default=None)
    """
    Aggregations: {alias: {function, field}}
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
